<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/Echo/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Echo/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Echo/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Echo/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5ZQ9pmEjPOsQmbBYQoUK41fLaMMyEK5pDRa34TE8fW4">
  <meta name="msvalidate.01" content="58AE2D56435A76DA1BF1341C2E6930C1">

<link rel="stylesheet" href="/Echo/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hugfeature.github.io","root":"/Echo/","images":"/Echo/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/Echo/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/Echo/js/config.js"></script>
<meta name="description" content="曾经梦想仗剑走天涯!因为遇见她，所以回了家！">
<meta property="og:type" content="website">
<meta property="og:title" content="测试的名义">
<meta property="og:url" content="https://hugfeature.github.io/Echo/archives/index.html">
<meta property="og:site_name" content="测试的名义">
<meta property="og:description" content="曾经梦想仗剑走天涯!因为遇见她，所以回了家！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="丑牛">
<meta property="article:tag" content="大数据测试，性能测试，测试，自动化测试，K8S，Kubernetes，接口测试，测试管理，测试计划，测试策略">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hugfeature.github.io/Echo/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>测试的名义 - Stay hungry, Stay foolish</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SY6RK3NESF"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SY6RK3NESF","only_pageview":false}</script>
  <script src="/Echo/js/third-party/analytics/google-analytics.js"></script>




  <script async src="https://www.clarity.ms/tag/myblog"></script>

  <noscript>
    <link rel="stylesheet" href="/Echo/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Echo/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">测试的名义</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/Echo/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/Echo/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-categories"><a href="/Echo/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/Echo/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">丑牛</p>
  <div class="site-description" itemprop="description">曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/Echo/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/Echo/tags/">
        <span class="site-state-item-count">60</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hugfeature/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hugfeature&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hugfeature" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/932578fc.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/932578fc.html" class="post-title-link" itemprop="url">大数据面试-Flume</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-07 22:12:00" itemprop="dateCreated datePublished" datetime="2022-04-07T22:12:00+08:00">2022-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="一、Flume使用场景"><a href="#一、Flume使用场景" class="headerlink" title="一、Flume使用场景"></a>一、Flume使用场景</h4><p>线上数据一般主要是落地（存储到磁盘）或者通过 socket 传输给另外一个系统，这种情况下，你很难推动线上应用或服务去修改接口，实现直接向 kafka里写数据，这时候你可能就需要 flume 这样的系统帮你去做传输。</p>
<h4 id="二、Flume丢包问题"><a href="#二、Flume丢包问题" class="headerlink" title="二、Flume丢包问题"></a>二、Flume丢包问题</h4><p>单机 upd 的 flume source 的配置，100+M&#x2F;s 数据量，10w qps flume 就开始大量丢包，因此很多公司在搭建系统时，抛弃了 Flume，自己研发传输系统，但是往往会参考 Flume 的 Source-Channel-Sink 模式。一些公司在 Flume 工作过程中，会对业务日志进行监控，例如 Flume agent中有多少条日志，Flume 到 Kafka 后有多少条日志等等，如果数据丢失保持在1%左右是没有问题的，当数据丢失达到 5%左右时就必须采取相应措施。</p>
<h4 id="三、Flume与KAFKA的选取"><a href="#三、Flume与KAFKA的选取" class="headerlink" title="三、Flume与KAFKA的选取"></a>三、Flume与KAFKA的选取</h4><p>采集层主要可以使用 Flume、Kafka 两种技术。</p>
<p>Flume：Flume 是管道流方式，提供了很多的默认实现，让用户通过参数部署，及扩展 API。<br>Kafka：Kafka 是一个可持久化的分布式的消息队列。<br>Kafka 是一个非常通用的系统。你可以有许多生产者和很多的消费者共享多个主题 Topics。相比之下，Flume 是一个专用工具被设计为旨在往 HDFS，HBase 发送数据。它对 HDFS 有特殊的优化，并且集成了 Hadoop 的安全特性。所以，Cloudera 建议如果数据被多个系统消费的话，使用 kafka；如果数据被设计给 Hadoop 使用，使用 Flume。<br>正如你们所知 Flume 内置很多的 source 和 sink 组件。然而，Kafka 明显有一个更小的生产消费者生态系统，并且 Kafka 的社区支持不好。希望将来这种情况会得到改善，但是目前：使用 Kafka 意味着你准备好了编写你自己的生产者和消费者代码。如果已经存在的 Flume Sources 和 Sinks 满足你的需求，并且你更喜欢不需要任何开发的系统，请使用 Flume。<br>Flume 可以使用拦截器实时处理数据。这些对数据屏蔽或者过量是很有用的。<br>Kafka 需要外部的流处理系统才能做到。<br>Kafka 和 Flume 都是可靠的系统，通过适当的配置能保证零数据丢失。然而，Flume 不支持副本事件。于是，如果 Flume 代理的一个节点奔溃了，即使使用了可靠的文件管道方式，你也将丢失这些事件直到你恢复这些磁盘。如果你需要一个高可靠性的管道，那么使用 Kafka 是个更好的选择。<br>Flume 和 Kafka 可以很好地结合起来使用。如果你的设计需要从 Kafka 到Hadoop 的流数据，使用 Flume 代理并配置 Kafka 的 Source 读取数据也是可行的：你没有必要实现自己的消费者。你可以直接利用 Flume 与 HDFS 及HBase 的结合的所有好处。你可以使用 Cloudera Manager 对消费者的监控，并且你甚至可以添加拦截器进行一些流处理。</p>
<h4 id="四、数据怎么采集到KAFKA，实现方式？"><a href="#四、数据怎么采集到KAFKA，实现方式？" class="headerlink" title="四、数据怎么采集到KAFKA，实现方式？"></a>四、数据怎么采集到KAFKA，实现方式？</h4><p>使用官方提供的 flumeKafka 插件，插件的实现方式是自定义了 flume 的sink，将数据从 channle 中取出，通过 kafka 的 producer 写入到 kafka 中，可以自定义分区等。</p>
<h4 id="五、Flume管道内存，flume宕机了数据丢失怎么解决？"><a href="#五、Flume管道内存，flume宕机了数据丢失怎么解决？" class="headerlink" title="五、Flume管道内存，flume宕机了数据丢失怎么解决？"></a>五、Flume管道内存，flume宕机了数据丢失怎么解决？</h4><p>1）Flume 的 channel 分为很多种，可以将数据写入到文件。<br>2）防止非首个 agent 宕机的方法数可以做集群或者主备。</p>
<h4 id="六、flume配置方式，flume集群"><a href="#六、flume配置方式，flume集群" class="headerlink" title="六、flume配置方式，flume集群"></a>六、flume配置方式，flume集群</h4><p>Flume 的配置围绕着 source、channel、sink 叙述，flume 的集群是做在agent 上的，而非机器上。</p>
<h4 id="七、flume不采集nginx日志，通过log4j采集日志，优缺点是什么？"><a href="#七、flume不采集nginx日志，通过log4j采集日志，优缺点是什么？" class="headerlink" title="七、flume不采集nginx日志，通过log4j采集日志，优缺点是什么？"></a>七、flume不采集nginx日志，通过log4j采集日志，优缺点是什么？</h4><p>优点：Nginx 的日志格式是固定的，但是缺少 sessionid，通过 logger4j 采集的日志是带有 sessionid 的，而 session 可以通过 redis 共享，保证了集群日志中的同一 session 落到不同的 tomcat 时，sessionId 还是一样的，而且logger4j 的方式比较稳定，不会宕机。</p>
<p>缺点：不够灵活，logger4j 的方式和项目结合过于紧密，而 flume 的方式比较灵活，拔插式比较好，不会影响项目性能。</p>
<h4 id="八、flume-和-kafka-采集日志区别，采集日志时中间停了，怎么记录之前的日志？"><a href="#八、flume-和-kafka-采集日志区别，采集日志时中间停了，怎么记录之前的日志？" class="headerlink" title="八、flume 和 kafka 采集日志区别，采集日志时中间停了，怎么记录之前的日志？"></a>八、flume 和 kafka 采集日志区别，采集日志时中间停了，怎么记录之前的日志？</h4><p>Flume 采集日志是通过流的方式直接将日志收集到存储层，而 kafka 是将缓存在 kafka 集群，待后期可以采集到存储层。<br>Flume 采集中间停了，可以采用文件的方式记录之前的日志，而 kafka 是采用 offset 的方式记录之前的日志。</p>
<p>九、flume有哪些组件，具体是做什么的？</p>
<p><img src="/Echo/posts/undefined/image-20220408151914983.png" alt="image-20220408151914983"></p>
<p>1）source：用于采集数据，Source 是产生数据流的地方，同时 Source 会将产生的数据流传输到 Channel，这个有点类似于 Java IO 部分的 Channel。<br>2）channel：用于桥接 Sources 和 Sinks，类似于一个队列。<br>3）sink：从 Channel 收集数据，将数据写到目标源(可以是下一个 Source，也可以是 HDFS 或者 HBase)。<br>PS：要熟悉 source、channel、sink 的类型</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/e01df792.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/e01df792.html" class="post-title-link" itemprop="url">大数据面试-KAFKA</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-07 19:34:53" itemprop="dateCreated datePublished" datetime="2022-04-07T19:34:53+08:00">2022-04-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="一、为什么使用KAFKA？"><a href="#一、为什么使用KAFKA？" class="headerlink" title="一、为什么使用KAFKA？"></a>一、为什么使用KAFKA？</h4><ul>
<li>缓冲和削峰：上游数据时有突发流量，下游可能扛不住，或者下游没有足够多的机器来保证冗余，kafka 在中间可以起到一个缓冲的作用，把消息暂存在 kafka 中，下游服务就可以按照自己的节奏进行慢慢处理。</li>
<li>解耦和扩展性：项目开始的时候，并不能确定具体需求。消息队列可以作为一个接口层，解耦重要的业务流程。只需要遵守约定，针对数据编程即可获取扩展能力。</li>
<li>冗余：可以采用一对多的方式，一个生产者发布消息，可以被多个订阅 topic 的服务消费到，供多个毫无关联的业务使用。</li>
<li>健壮性：消息队列可以堆积请求，所以消费端业务即使短时间死掉，也不会影响主要业务的正常进行。</li>
<li>异步通信：很多时候，用户不想也不需要立即处理消息。消息队列提供了异步处理机制，允许用户把一个消息放入队列，但并不立即处理它。想向队列中放入多少消息就放多少，然后在需要的时候再去处理它们。</li>
</ul>
<h4 id="二、KAKFA消费过的消息如何再消费？"><a href="#二、KAKFA消费过的消息如何再消费？" class="headerlink" title="二、KAKFA消费过的消息如何再消费？"></a>二、KAKFA消费过的消息如何再消费？</h4><p>kafka 消费消息的 offset 是定义在 zookeeper 中的， 如果想重复消费 kafka 的消息，可以在 redis 中自己记录 offset 的 checkpoint 点（n 个），当想重复消费消息时，通过读取 redis 中的 checkpoint 点进行 zookeeper 的 offset 重设，这样就可以达到重复消费消息的目的。</p>
<h4 id="三、KAFKA的数据是存放在磁盘上还是内存上，为什么速度会快？"><a href="#三、KAFKA的数据是存放在磁盘上还是内存上，为什么速度会快？" class="headerlink" title="三、KAFKA的数据是存放在磁盘上还是内存上，为什么速度会快？"></a>三、KAFKA的数据是存放在磁盘上还是内存上，为什么速度会快？</h4><p>kafka 使用的是磁盘存储。<br>速度快的原因是：</p>
<ul>
<li>顺序写入：因为硬盘是机械结构，每次读写都会寻址-&gt;写入，其中寻址是一个“机械动作”，它是耗时的。所以硬盘 “讨厌”随机 I&#x2F;O， 喜欢顺序 I&#x2F;O。为了提高读写硬盘的速度，Kafka 就是使用顺序 I&#x2F;O。</li>
<li>Memory Mapped Files（内存映射文件）：64位操作系统中一般可以表示 20G 的数据文件，它的工作原理是直接利用操作系统的Page 来实现文件到物理内存的直接映射。完成映射之后你对物理内存的操作会被同步到硬盘上。</li>
<li>Kafka 高效文件存储设计： Kafka 把 topic 中一个 parition 大文件分成多个小文件段，通过多个小文件段，就容易定期清除或删除已经消费完文件，减少磁盘占用。通过索引信息可以快速定位message 和确定 response 的 大 小。通过 index 元数据全部映射到 memory（内存映射文件），可以避免 segment file 的 IO 磁盘操作。通过索引文件稀疏存储，可以大幅降低index 文件元数据占用空间大小。</li>
</ul>
<h4 id="四、KAFKA数据怎么保障不丢失？"><a href="#四、KAFKA数据怎么保障不丢失？" class="headerlink" title="四、KAFKA数据怎么保障不丢失？"></a>四、KAFKA数据怎么保障不丢失？</h4><p>分三个点说，一个是生产者端，一个消费者端，一个 broker 端。</p>
<h5 id="生产者数据的不丢失"><a href="#生产者数据的不丢失" class="headerlink" title="生产者数据的不丢失"></a>生产者数据的不丢失</h5><p>kafka 的 ack 机制：在 kafka 发送数据的时候，每次发送消息都会有一个确认反馈机制，确保消息正常的能够被收到，其中状态有 0，1，-1。<br>如果是同步模式：<br>ack 设置为 0，风险很大，一般不建议设置为 0。即使设置为 1，也会随着 leader 宕机丢失数据。所以如果要严格保证生产端数据不丢失，可设置为-1。<br>如果是异步模式：<br>也会考虑 ack 的状态，除此之外，异步模式下的有个 buffer，通过 buffer 来进行控制数据的发送，有两个值来进行控制，时间阈值与消息的数量阈值，如果 buffer 满了数据还没有发送出去，有个选项是配置是否立即清空 buffer。可以设置为-1，永久阻塞，也就数据不再生产。异步模式下，即使设置为-1。也可能因为程序员的不科学操作，操作数据丢失，比如 kill -9，但这是特别的例外情况。</p>
<p>ack&#x3D;0：producer 不等待 broker 同步完成的确认，继续发送下一条(批)信息。<br>ack&#x3D;1（默认）：producer 要等待 leader 成功收到数据并得到确认，才发送下一条message。<br>ack&#x3D;-1：producer 得到 follwer 确认，才发送下一条数据。</p>
<h5 id="消费者数据的不丢失"><a href="#消费者数据的不丢失" class="headerlink" title="消费者数据的不丢失"></a>消费者数据的不丢失</h5><p>通过 offset commit 来保证数据的不丢失，kafka 自己记录了每次消费的 offset 数值，下次继续消费的时候，会接着上次的 offset 进行消费。而 offset 的信息在 kafka0.8 版本之前保存在 zookeeper 中，在 0.8 版本之后保存到topic 中，即使消费者在运行过程中挂掉了，再次启动的时候会找到 offset 的值，找到之前消费消息的位置，接着消费，由于 offset 的信息写入的时候并不是每条消息消费完成后都写入的，所以这种情况有可能会造成重复消费，但是不会丢失消息。<br>唯一例外的情况是，我们在程序中给原本做不同功能的两个 consumer 组设KafkaSpoutConfig.bulider.setGroupid 的时候设置成了一样的 groupid，这种情况会导致这两个组共享同一份数据，就会产生组 A 消费 partition1，partition2 中的消息，组 B 消费 partition3 的消息，这样每个组消费的消息都会丢失，都是不完整的。为了保证每个组都独享一份消息数据，groupid 一定不要重复才行。</p>
<h5 id="kafka-集群中的-broker-的数据不丢失"><a href="#kafka-集群中的-broker-的数据不丢失" class="headerlink" title="kafka 集群中的 broker 的数据不丢失"></a>kafka 集群中的 broker 的数据不丢失</h5><p>每个 broker 中的 partition 我们一般都会设置有 replication（副本）的个数，生产者写入的时候首先根据分发策略（有 partition 按 partition，有 key 按 key，都没有轮询）写入到 leader 中，follower（副本）再跟 leader 同步数据，这样有了备份，也可以保证消息数据的不丢失。</p>
<h4 id="五、采集数据为什么选择-kafka？"><a href="#五、采集数据为什么选择-kafka？" class="headerlink" title="五、采集数据为什么选择 kafka？"></a>五、采集数据为什么选择 kafka？</h4><p>采集层 主要可以使用 Flume, Kafka 等技术。<br>Flume：Flume 是管道流方式，提供了很多的默认实现，让用户通过参数部署，及扩展 API.<br>Kafka：Kafka 是一个可持久化的分布式的消息队列。 Kafka 是一个非常通用的系统。可以有许多生产者和很多的消费者共享多个主题 Topics。相比之下,Flume 是一个专用工具被设计为旨在往 HDFS，HBase 发送数据。它对<br>HDFS 有特殊的优化，并且集成了 Hadoop 的安全特性。所以，Cloudera 建议如果数据被多个系统消费的话，使用 kafka；如果数据被设计给Hadoop 使用，使用 Flume。</p>
<h4 id="kafka-重启是否会导致数据丢失？"><a href="#kafka-重启是否会导致数据丢失？" class="headerlink" title="kafka 重启是否会导致数据丢失？"></a>kafka 重启是否会导致数据丢失？</h4><p>kafka 是将数据写到磁盘的，一般数据不会丢失。但是在重启 kafka 过程中，如果有消费者消费消息，那么 kafka 如果来不及提交 offset，可能会造成数据的不准确（丢失或者重复消费）。</p>
<h4 id="kafka-宕机了如何解决？"><a href="#kafka-宕机了如何解决？" class="headerlink" title="kafka 宕机了如何解决？"></a>kafka 宕机了如何解决？</h4><p>先考虑业务是否受到影响</p>
<p>kafka 宕机了，首先我们考虑的问题应该是所提供的服务是否因为宕机的机器而受到影响，如果服务提供没问题，如果实现做好了集群的容灾机制，那么这块就不用担心了。<br>节点排错与恢复<br>想要恢复集群的节点，主要的步骤就是通过日志分析来查看节点宕机的原因，从而解决，重新恢复节点。</p>
<h4 id="六、为什么-Kafka-不支持读写分离？"><a href="#六、为什么-Kafka-不支持读写分离？" class="headerlink" title="六、为什么 Kafka 不支持读写分离？"></a>六、为什么 Kafka 不支持读写分离？</h4><p>在 Kafka 中，生产者写入消息、消费者读取消息的操作都是与 leader 副本进行交互的，从 而实现的是一种主写主读的生产消费模型。<br>Kafka 并不支持主写从读，因为主写从读有 2 个很明显的缺点:</p>
<ul>
<li><p>数据一致性问题：数据从主节点转到从节点必然会有一个延时的时间窗口，这个时间窗口会导致主从节点之间的数据不一致。某一时刻，在主节点和从节点中 A 数据的值都为 X， 之后将主节点中 A 的值修改为 Y，那么在这个变更通知到从节点之前，应用读取从节点中的 A 数据的值并不为最新的 Y，由此便产生了数据不一致的问题。</p>
</li>
<li><p>延时问题：类似 Redis 这种组件，数据从写入主节点到同步至从节点中的过程需要经历 网络→主节点内存→网络→从节点内存 这几个阶段，整个过程会耗费一定的时间。而在Kafka 中，主从同步会比 Redis 更加耗时，它需要经历 网络→主节点内存→主节点磁盘→网络→从节 点内存→从节点磁盘 这几个阶段。对延时敏感的应用而言，主写从读的功能并不太适用。</p>
</li>
</ul>
<p>而 kafka 的主写主读的优点就很多了：<br>可以简化代码的实现逻辑，减少出错的可能; 将负载粒度细化均摊，与主写从读相比，不仅负载效能更好，而且对用户可控;没有延时的影响;在副本稳定的情况下，不会出现数据不一致的情况。</p>
<h4 id="七、kafka-数据分区和消费者的关系？"><a href="#七、kafka-数据分区和消费者的关系？" class="headerlink" title="七、kafka 数据分区和消费者的关系？"></a>七、kafka 数据分区和消费者的关系？</h4><p>每个分区只能由同一个消费组内的一个消费者(consumer)来消费，可以由不同的消费组的消费者来消费，同组的消费者则起到并发的效果。</p>
<h4 id="八、kafka-的数据-offset-读取流程"><a href="#八、kafka-的数据-offset-读取流程" class="headerlink" title="八、kafka 的数据 offset 读取流程"></a>八、kafka 的数据 offset 读取流程</h4><p>连接 ZK 集群，从 ZK 中拿到对应 topic 的 partition 信息和 partition 的 Leader 的相关信息连接到对应 Leader 对应的 brokerconsumer 将⾃自自⼰己己保存的 offset 发送给LeaderLeader 根据 offset 等信息定位到 segment（索引⽂文文件和⽇日日志⽂文文件）根据索引⽂文文件中的内容，定位到⽇日日志⽂文文件中该偏移量量对应的开始位置读取相应长长度的数据并返回给 consumer。</p>
<h4 id="九、kafka-内部如何保证顺序，结合外部组件如何保证消费者的顺序？"><a href="#九、kafka-内部如何保证顺序，结合外部组件如何保证消费者的顺序？" class="headerlink" title="九、kafka 内部如何保证顺序，结合外部组件如何保证消费者的顺序？"></a>九、kafka 内部如何保证顺序，结合外部组件如何保证消费者的顺序？</h4><p>kafka 只能保证 partition 内是有序的，但是 partition 间的有序是没办法的。爱奇艺的搜索架构，是从业务上把需要有序的打到同⼀一个 partition。</p>
<h4 id="十、Kafka-消息数据积压，Kafka-消费能力不足怎么处理？"><a href="#十、Kafka-消息数据积压，Kafka-消费能力不足怎么处理？" class="headerlink" title="十、Kafka 消息数据积压，Kafka 消费能力不足怎么处理？"></a>十、Kafka 消息数据积压，Kafka 消费能力不足怎么处理？</h4><p>如果是 Kafka 消费能力不足，则可以考虑增加 Topic 的分区数，并且同时提升消费组的消费者数量，消费者数&#x3D;分区数。（两者缺一不可）如果是下游的数据处理不及时：提高每批次拉取的数量。批次拉取数据过少（拉取数据&#x2F;处理时间&lt;生产速度），使处理的数据小于生产的数据，也会造成数据积压。</p>
<h4 id="十一、Kafka-单条日志传输大小"><a href="#十一、Kafka-单条日志传输大小" class="headerlink" title="十一、Kafka 单条日志传输大小"></a>十一、Kafka 单条日志传输大小</h4><p>kafka 对于消息体的大小默认为单条最大值是 1M 但是在我们应用场景中, 常常会出现一条消息大于 1M，如果不对 kafka 进行配置。则会出现生产者无法将消息推送到kafka 或消费者无法去消费 kafka 里面的数据, 这时我们就要对 kafka 进行以下配置：<br>server.properties<br>1replica.fetch.max.bytes: 1048576 broker 可复制的消息的最大字节数, 默认为 1M<br>2message.max.bytes: 1000012 kafka 会接收单个消息 size 的最大限制， 默认为1M 左右<br>注意：message.max.bytes 必须小于等于 replica.fetch.max.bytes，否则就会导致 replica 之间数据同步失败。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/c066093e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/c066093e.html" class="post-title-link" itemprop="url">大数据面试-HDFS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-06 13:24:06" itemprop="dateCreated datePublished" datetime="2022-04-06T13:24:06+08:00">2022-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="一、HDFS读写流程"><a href="#一、HDFS读写流程" class="headerlink" title="一、HDFS读写流程"></a>一、HDFS读写流程</h4><h5 id="①HDFS写流程"><a href="#①HDFS写流程" class="headerlink" title="①HDFS写流程"></a>①HDFS写流程</h5><p>1）client 客户端发送上传请求，通过 RPC 与 namenode 建立通信，namenode 检查该用户是否有上传权限，以及上传的文件是否在 hdfs 对应的目录下重名，如果这两者有任意一个不满足，则直接报错，如果两者都满足，则返回给客户端一个可以上传的信息。</p>
<p>2）client 根据文件的大小进行切分，默认 128M 一块，切分完成之后给namenode 发送请求第一个 block 块上传到哪些服务器上。</p>
<p>3）namenode 收到请求之后，根据网络拓扑和机架感知以及副本机制进行文件分配，返回可用的 DataNode 的地址</p>
<p>4）客户端收到地址之后与服务器地址列表中的一个节点如 A 进行通信，本质上就是 RPC 调用，建立 pipeline，A 收到请求后会继续调用 B，B 在调用 C，将整个 pipeline 建立完成，逐级返回 client。</p>
<p>5）client 开始向 A 上发送第一个 block（先从磁盘读取数据然后放到本地内存缓存），以 packet（数据包，64kb）为单位，A 收到一个 packet 就会发送给B，然后 B 发送给 C，A 每传完一个 packet 就会放入一个应答队列等待应答</p>
<p>6）数据被分割成一个个的 packet 数据包在 pipeline 上依次传输，在pipeline 反向传输中，逐个发送 ack（命令正确应答），最终由 pipeline 中第一个 DataNode 节点 A 将 pipelineack 发送给 Client。</p>
<p>7）当一个 block 传输完成之后, Client 再次请求 NameNode 上传第二个block ，namenode 重新选择三台 DataNode 给 client</p>
<h5 id="②HDFS读流程"><a href="#②HDFS读流程" class="headerlink" title="②HDFS读流程"></a>②HDFS读流程</h5><p>1）client 向 namenode 发送 RPC 请求。请求文件 block 的位置<br>2）namenode 收到请求之后会检查用户权限以及是否有这个文件，如果都符合，则会视情况返回部分或全部的 block 列表，对于每个 block，NameNode都会返回含有该 block 副本的 DataNode 地址； 这些返回的 DN 地址，会按照集群拓扑结构得出 DataNode 与客户端的距离，然后进行排序，排序两个规则：网络拓扑结构中距离 Client近的排靠前；心跳机制中超时汇报的 DN 状态为 STALE，这样的排靠后<br>3）Client 选取排序靠前的 DataNode 来读取 block，如果客户端本身就是DataNode,那么将从本地直接获取数据(短路读取特性)<br>4）底层上本质是建立 Socket Stream（FSDataInputStream），重复的调用父类 DataInputStream 的 read 方法，直到这个块上的数据读取完毕<br>5）当读完列表的 block 后，若文件读取还没有结束，客户端会继续向NameNode 获取下一批的 block 列表<br>6）读取完一个 block 都会进行 checksum 验证，如果读取 DataNode 时出现错误，客户端会通知 NameNode，然后再从下一个拥有该 block 副本的DataNode 继续读<br>7）read 方法是并行的读取 block 信息，不是一块一块的读取；NameNode只是返回 Client 请求包含块的 DataNode 地址，并不是返回请求块的数据<br>8） 最终读取来所有的 block 会合并成一个完整的最终文件</p>
<h4 id="二、HDFS-在读取文件的时候-如果其中一个块突然损坏了怎么办"><a href="#二、HDFS-在读取文件的时候-如果其中一个块突然损坏了怎么办" class="headerlink" title="二、HDFS 在读取文件的时候,如果其中一个块突然损坏了怎么办"></a>二、HDFS 在读取文件的时候,如果其中一个块突然损坏了怎么办</h4><p>客户端读取完 DataNode 上的块之后会进行 checksum 验证，也就是把客户端读取到本地的块与 HDFS 上的原始块进行校验，如果发现校验结果不一致，客户端会通知NameNode，然后再从下一个拥有该 block 副本的 DataNode 继续读。</p>
<h4 id="三、HDFS-在上传文件的时候-如果其中一个-DataNode-突然挂掉了怎么办"><a href="#三、HDFS-在上传文件的时候-如果其中一个-DataNode-突然挂掉了怎么办" class="headerlink" title="三、HDFS 在上传文件的时候,如果其中一个 DataNode 突然挂掉了怎么办"></a>三、HDFS 在上传文件的时候,如果其中一个 DataNode 突然挂掉了怎么办</h4><p>客户端上传文件时与 DataNode 建立 pipeline 管道，管道正向是客户端向DataNode 发送的数据包，管道反向是 DataNode 向客户端发送 ack 确认，也就是正确接收到数据包之后发送一个已确认接收到的应答，当 DataNode 突然挂掉了，客户端接收不到这个 DataNode 发送的 ack 确认，客户端会通知 NameNode，NameNode 检查该块的副本与规定的不符，NameNode 会通知 DataNode 去复制副本，并将挂掉的 DataNode 作下线处理，不再让它参与文件上传与下载。</p>
<h4 id="四、HDFS-的组织架构"><a href="#四、HDFS-的组织架构" class="headerlink" title="四、HDFS 的组织架构"></a>四、HDFS 的组织架构</h4><p>1）Client：客户端<br>（1）切分文件。文件上传 HDFS 的时候，Client 将文件切分成一个一个的 Block，然后进行存储<br>（2）与 NameNode 交互，获取文件的位置信息<br>（3）与 DataNode 交互，读取或者写入数据<br>（4）Client 提供一些命令来管理 HDFS，比如启动关闭 HDFS、访问 HDFS 目录及内容等<br>2）NameNode：名称节点，也称主节点，存储数据的元数据信息，不存储具体的数据<br>（1）管理 HDFS 的名称空间<br>（2）管理数据块（Block）映射信息<br>（3）配置副本策略<br>（4）处理客户端读写请求<br>3）DataNode：数据节点，也称从节点。NameNode 下达命令，DataNode 执行实际的操作<br>（1）存储实际的数据块<br>（2）执行数据块的读&#x2F;写操作<br>4）Secondary NameNode：并非 NameNode 的热备。当 NameNode 挂掉的时候，它并不能马上替换NameNode 并提供服务<br>（1）辅助 NameNode，分担其工作量<br>（2）定期合并 Fsimage 和 Edits，并推送给 NameNode<br>（3）在紧急情况下，可辅助恢复 NameNode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/6baa0397.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/6baa0397.html" class="post-title-link" itemprop="url">Kubernetes--master、node</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-15 16:02:30" itemprop="dateCreated datePublished" datetime="2022-03-15T16:02:30+08:00">2022-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/kubernetes/" itemprop="url" rel="index"><span itemprop="name">kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p> Kubernetes里的Master指的是集群控制节点，在每个Kubernetes集群里都需要有一个Master来负责整个集群的管理和控制，基本上Kubernetes的所有控制命令都发给它，它负责具体的执行过程，我们后面执行的所有命令基本都是在Master上运行的。Master通常会占据一个独立的服务器（高可用部署建议用3台服务器），主要原因是它太重要了，是整个集群的“首脑”，如果它宕机或者不可用，那么对集群内容器应用的管理都将失效。<br>在Master上运行着以下关键进程。</p>
<ul>
<li>Kubernetes API Server（kube-apiserver）：提供了HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程。</li>
<li>Kubernetes Controller Manager（kube-controller-manager）：Kubernetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的“大总管”。</li>
<li>Kubernetes Scheduler（kube-scheduler）：负责资源调度（Pod调度）的进程，相当于公交公司的“调度室”。另外，在Master上通常还需要部署etcd服务，因为Kubernetes里的所有资源对象的数据都被保存在etcd中。</li>
</ul>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>除了Master，Kubernetes集群中的其他机器被称为Node，在较早的版本中也被称为Minion。与Master一样，Node可以是一台物理主机，也可以是一台虚拟机。Node是Kubernetes集群中的工作负载节点，每个Node都会被Master分配一些工作负载（Docker容器），当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上。<br>在每个Node上都运行着以下关键进程。</p>
<ul>
<li>kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能</li>
<li>kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件。</li>
<li>Docker Engine（docker）：Docker引擎，负责本机的容器创建和管理工作。</li>
</ul>
<p>Node可以在运行期间动态增加到Kubernetes集群中，前提是在这个节点上已经正确安装、配置和启动了上述关键进程，在默认情况下kubelet会向Master注册自己，这也是Kubernetes推荐的Node管理方式。一旦Node被纳入集群管理范围，kubelet进程就会定时向Master汇报自身的情报，例如操作系统、Docker版本、机器的CPU和内存情况，以及当前有哪些Pod在运行等，这样Master就可以获知每个Node的资源使用情况，并实现高效均衡的资源调度策略。而某个Node在超过指定时间不上报信息时，会被Master判定为“失联”，Node的状态被标记为不可用<br>（Not Ready），随后Master会触发“工作负载大转移”的自动流程。</p>
<p>可以通过kubectl get nodes查看集群中有多少个node，然后可以通过kubectl describe node <node_ name>来查看某个node的具体信息。describe展示node的关键信息如下：</node_></p>
<ul>
<li>Node的基本信息：名称、标签、创建时间等。</li>
<li>Node当前的运行状态：Node启动后会做一系列的自检工作，比如磁盘空间是否不足（DiskPressure）、内存是否不足（MemoryPressure）、网络是否正常（NetworkUnavailable）、PID资源是否充（PIDPressure）。在一切正常时设置Node为Ready状态（Ready&#x3D;True），该状态表示Node处于健康状态，Master将可以在其上调度新的任务了（如启动Pod）。</li>
<li>Node的主机地址与主机名。</li>
<li>Node上的资源数量：描述Node可用的系统资源，包括CPU、内存数量、最大可调度Pod数量等。</li>
<li>Node可分配的资源量：描述Node当前可用于分配的资源量。</li>
<li>主机系统信息：包括主机ID、系统UUID、Linux  kernel版本号、操作系统类型与版本、Docker版本号、kubelet与kube-proxy的版本号等。</li>
<li>当前运行的Pod列表概要信息。</li>
<li>已分配的资源使用概要信息，例如资源申请的最低、最大允许使用量占系统总量的百分比。</li>
<li>Node相关的Event信息。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/82ff0530.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/82ff0530.html" class="post-title-link" itemprop="url">成为高效的测试主管</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 22:42:40" itemprop="dateCreated datePublished" datetime="2022-03-01T22:42:40+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如何成为高效的测试主管，打造一个更快乐、更成功的测试团队</p>
<h4 id="技能1-具备业务知识和技术技能"><a href="#技能1-具备业务知识和技术技能" class="headerlink" title="技能1  具备业务知识和技术技能"></a>技能1  具备业务知识和技术技能</h4><ul>
<li><p>一个组织通常会提出其业务目标，这些目标从更高级别的管理层一直转化为每个团队和个人。测试主管必须对项目路线图、总体组织目标、利益干系人和客户需求有良好的控制。在任何给定的时刻，他们必须能够提供任何测试团队成员所需的指导，以帮助他们了解他&#x2F;她正在扮演什么角色，以符合项目的成功，并且必须使他们能够看到更大的图景。</p>
</li>
<li><p>大多数情况下，测试人员发现测试主管可能无法完全理解他们在测试时面临的技术问题。测试主管必须具备所需的技能，以便能够使用任何工具，环境，系统等指导测试人员，并提供解决方案以克服他们可能面临的任何问题。在关键时刻，他们还必须自己承担一些工作，以减轻团队的负担。</p>
</li>
<li><p>业务本质上是非常动态的，很多时候，新的测试项目可能会在发布结束时添加。有时，已经测试过的项目可能会取消范围。在这两种情况下，测试主管必须指导测试人员，使他们能够客观地查看范围变化。测试线索的这种能力能够在技术上和其他方面指导团队，这将有助于团队成员依赖测试线索。</p>
</li>
</ul>
<h4 id="技能2-工作量估算和有效分配工作"><a href="#技能2-工作量估算和有效分配工作" class="headerlink" title="技能2 工作量估算和有效分配工作"></a>技能2 工作量估算和有效分配工作</h4><ul>
<li><p>当需求文档浮出水面时，测试主管和他的测试人员团队将编写测试计划，该计划将定义范围，硬件，软件，要测试的功能，计划等。在此基础上，对所需工作量进行规模估计，并进行适当的工作分配。</p>
</li>
<li><p>在测试团队中，有一些资深人士和一些初级人士。必须通过评估每个测试人员的利益来进行仔细的评估。任务必须使他们获得的工作不仅要让他们兴奋，还要建立在他们现有的知识库之上。</p>
</li>
<li><p>测试团队中的另一个常见问题是工作负载平衡。繁重的工作量是测试团队的重要组成部分，不断推动您的团队加班可能会导致饱和。如果潜在客户检测到可能存在繁重的工作负载，必须由更少的资源来覆盖，则必须尽早制定适当的缓解计划。在某些不可避免的情况下，必须随时向团队发布这是不可预见的情况，并且非常感谢他们愿意扩展。</p>
</li>
<li><p>其次，即使具有丰富经验的高级测试人员可以涵盖各种各样的行项目，但向他们施加更多的工作和责任肯定会阻止他们完成测试目标的兴趣。承担一些经过计算的风险，并将具有挑战性的物品分配给初级会员。他们渴望了解和成长，这可能有助于发展团队。</p>
</li>
</ul>
<h4 id="技能3-尽量不要过度提交"><a href="#技能3-尽量不要过度提交" class="headerlink" title="技能3 尽量不要过度提交"></a>技能3 尽量不要过度提交</h4><ul>
<li>通常，测试领导者，为了突出团队的技能，通过过度投入来给团队带来压力。现在，过度承诺可能意味着一个广泛的领域。</li>
</ul>
<p>例：如果在测试团队开始测试时测试范围发生了变化，并且认为测试内容增加。在这种情况下，当测试主管被要求提供有关尺寸和完成所需时间的输入时，往往会过度承诺他们可以花费更长的时间&#x2F;周末，并在相同的持续时间内”挤压”测试，而不会影响质量。这不仅设定了一个永久的期望，即测试团队将始终扩展自己，而且还迫使他们做出很多个人牺牲。</p>
<ul>
<li><p>在某些其他时候，过度投入可能意味着在发现缺陷&#x2F;逃避方面对测试团队设定不合理的期望。了解测试人员是人类，容易出错的基本事实至关重要。因此，设置过度不切实际的目标，即可以忽略不计&#x2F;没有缺陷逃逸是令人沮丧的，因为测试人员往往会对测试团队之外可能发现的任何缺陷负责。</p>
</li>
<li><p>过度投入会导致倦怠。在前一种情况下，测试范围发生变化，请与管理层进行相应的测试计划协商。在后一种情况下，要明白生活中没有什么是没有错误的，设定这样的目标只有在理论上听起来很棒。</p>
</li>
</ul>
<h4 id="技能4-各级沟通，人际交往能力"><a href="#技能4-各级沟通，人际交往能力" class="headerlink" title="技能4 各级沟通，人际交往能力"></a>技能4 各级沟通，人际交往能力</h4><p>无论是通过电子邮件，电话还是人际关系层面的沟通都应该是清单上的第一项，但就像它所说 - 将最好的留到最后。让我们来看看这如何影响几乎所有的技术和非技术方面。</p>
<p><strong>了解如何提出异议：</strong></p>
<p>作为测试主管，你是管理层和测试团队之间的接口。实际上没有”格式”可以与任何一方意见相左，但是当情况需要时，必须这样做。当然，有办法做到这一点。当涉及到测试人员时，您需要采取更敏感或更柔和的方法。</p>
<p>说到管理，你可能必须让他们看到你的想法的价值，而不是他们的事实信息。</p>
<p><strong>谈判技巧</strong>:</p>
<p>测试项目总是有一系列挑战，如环境问题，管理对测试进度的关注，管理层和各个团队之间对目标的理解不同，团队成员内部以及团队成员与管理层之间的人际关系问题&#x2F;冲突。在这种时候，测试领导者很难通过这些挑战看到光明。</p>
<p>有时高层不是很容易打交道，因此重要的是要以一种让另一方觉得他们的意见得到了考虑的方式进行谈判。同样，领导必须能够推动冲突的解决，其中双方都认为中间立场是他们可以同意的。</p>
<p><strong>鼓励与开发协作</strong>:</p>
<p>通常，当开发团队拒绝限制的缺陷时，测试人员会感到沮丧。虽然他们每个人都来自他们来自哪里，但这往往会导致测试和开发之间的”我们vs他们”的态度。测试负责人应推动测试团队与开发建立健康和协作的关系。</p>
<p><strong>将看到的两个好处：</strong></p>
<ul>
<li>测试人员可以更好地了解该功能的背景及其局限性和</li>
<li>开发人员了解最终用户如何看待代码。</li>
</ul>
<p><strong>向上级管理层报告和电子邮件通信：</strong></p>
<p>测试主管的很大一部分时间用于准备状态报告并向管理层报告进度。领导者是管理团队看到测试团队努力的窗口，因此他必须能够以清晰易懂的方式报告信息。</p>
<p>报告必须非常清楚地突出测试人员的成就，以使管理层能够立即意识到这一点。它还应该描述测试团队面临的问题，团队已经尝试或将要尝试的一系列事情，以解决这个问题，并且在超出他们控制范围的情况下，清楚地说明这一点 - 要求管理层指导解决。</p>
<p>即使测试团队的进度达不到标准，领导也必须能够向管理层灌输信心，即测试团队正在以最佳质量执行以满足最后期限。</p>
<p><strong>团队会议：</strong></p>
<p>毋庸置疑，测试负责人必须推动内部会议。这些会议将使他能够了解每个测试人员的任务，他当前的进展以及阻碍他进步的问题。牵头人应讨论与根本原因接近的问题，并就如何克服这些问题提出建议&#x2F;方法。</p>
<p>这个论坛也可以用来向团队成员传递赞赏或赞美，鼓励他们表现得更好，激励他人。偶尔发一封电子邮件来感谢他们的贡献，这是一个非常好的主意，可以让测试人员保持动力，让他们表现出色！</p>
<p>团队会议还可以使测试负责人确保测试人员在测试基础架构、项目清晰度、开发支持良好的缺陷周转时间等方面拥有他们所需要的东西。</p>
<p>团队会议形成了一个很好的平台来举行头脑风暴会议，其输出可以导致创新，流程改进，以执行日常工作。</p>
<p>除了技术方面，团队会议还使测试负责人能够与记者建立健康的关系。反过来，这也可以证明是他的一种学习，通过定期询问如何更好地管理的反馈。口头禅很简单：你成长，我成长！</p>
<p><strong>提供空间：</strong></p>
<p>特别是测试团队主要由不同的人员组成，每个人员都有自己的工作风格。大多数测试主管经常犯一个错误，即试图在团队中强制实施统一的文化，而这种文化在过去可能对他很有效。基本规则是让人们做自己的事情，除非它严重阻碍了项目进度。</p>
<p>在关键的里程碑日期 - 如果要求测试团队必须工作到很晚，周末才能满足时间表，给他们空间和自由，以他们希望的方式工作，这是最重要的。为每个人提供备份，以便让人们在需要的时候休息一下是可以的。</p>
<p>还要向他们保证，一旦达到最后期限，他们可以花一些时间充电。</p>
<p>特别是在一个成熟的测试团队中，几乎所有资源都有相当多的经验和可信度，强迫某些管理文化会导致公开的分歧和争论。了解团队在技术上所做的工作，提出有价值的建议，并让他们采取实现里程碑所需的东西。</p>
<p>不要时不时地出现在他们的办公桌前要求更新状态。这给这个人带来了很大的压力，如果他那天无法克服某个特定问题，就会有一种失败&#x2F;怨恨的感觉。</p>
<p>在命令中做第二个:</p>
<p>任何领导者的首要目标必须是创造火炬手;即创造其他领导者。事实上，这是优秀领导者最独特的品质之一。对于初级成员来说，虽然敏锐地回顾他们正在做的事情很重要，但如果他们被允许承认自己的角色，这对他们来说将是无价的学习。</p>
<p><strong>例如，</strong>如果他们在测试时遇到问题，使他们能够进行研究，跟进开发并推动其独立完成，除非有必要进行干预。这将有助于他们的成长。</p>
<p>与高级成员一起 - 让他们参与关键决策活动。他们的经验可以被证明是一种资产，所以要好好利用它。确保他们被投射为自己的领导者，将你自己的部分责任委托给他们。通过制作一个伙伴系统来授权他们指导初级成员，这将平等地帮助两个成员。</p>
<p><strong>电子邮件通信：</strong></p>
<p>这可能应该是这里几乎所有项目的子弹，也是企业领域任何个人的必备品质，更不用说领导者了。无论是准备报告，演讲，审查过程，传递赞赏等，拥有良好的沟通技巧对于有效表达自己至关重要。</p>
<h4 id="技能5-个人品质"><a href="#技能5-个人品质" class="headerlink" title="技能5 个人品质"></a>技能5 个人品质</h4><p>归根结底，测试人员是有感情的人。如果你的团队想发挥出他们最好的一面，并因为你的影响力而进一步扩大自己——那就把它看作是你最大的胜利。</p>
<ul>
<li>直截了当是成为优秀领导者的标志性标志。您的团队将能够依靠您分享哪些信息，并使您更容易接近他们。</li>
<li>对你的职位没有自我问题。如果你犯了一个错误，请毫无问题地为此道歉！</li>
<li>始终与团队分享您的荣誉，因为毕竟，只有您的团队闪耀，您才会发光。</li>
<li>尝试使用”我们的”，”我们”，”我们”而不是我，你，他或她。灌输一种相互主人翁意识。</li>
<li>表现出对工作的热情。为了让团队对自己的工作充满热情并与之相关，责任在于测试线索，以辐射这种能量。</li>
<li>即使在工作中也能享受自己。虽然大多数情况下都有团队活动和有趣的活动计划，但没有规定乐趣必须限制在某一天。我们一起度过了一天中的大部分时间都，事情压力很大。一起喝茶，共进午餐，庆祝生日，计划一些即兴活动。这将在很大程度上有助于加强人际关系。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/e907959e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/e907959e.html" class="post-title-link" itemprop="url">测试领导职责及如何有效管理测试团队</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 21:31:53" itemprop="dateCreated datePublished" datetime="2022-03-01T21:31:53+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="测试主管的职责"><a href="#测试主管的职责" class="headerlink" title="测试主管的职责"></a>测试主管的职责</h5><ol>
<li>他必须能够确定他的测试团队如何在组织内保持一致，以及他的团队将如何实现为项目和组织确定的路线图。</li>
<li>他需要根据文档的要求确定特定版本所需的测试范围。</li>
<li>在与测试团队讨论后，制定测试计划，并由管理&#x2F;开发团队进行审查和批准。</li>
<li>必须确定所需的指标并努力使其到位。这些指标可能是测试团队的固有目标。</li>
<li>必须通过计算给定版本所需的大小来确定所需的测试工作，并计划相同的所需工作量。</li>
<li>弄清楚需要哪些技能，并根据自己的兴趣相应地平衡测试资源与这些需求。并确定是否存在任何技能差距，并计划为已确定的测试资源进行培训和教育课程。</li>
<li>确定用于测试报告、测试管理、测试自动化等的工具，并教育团队如何使用这些工具。同样，如果需要，请向团队成员计划知识传授课程，以获取他们将使用的工具。</li>
<li>通过向他们灌输领导力来保留熟练的资源，并在需要时为初级资源提供指导，从而使他们能够成长。</li>
<li>为所有资源创造有趣和有利的环境，以确保它们具有最大的吞吐量。</li>
</ol>
<h5 id="有效管理测试团队"><a href="#有效管理测试团队" class="headerlink" title="有效管理测试团队"></a>有效管理测试团队</h5><ol>
<li>启动测试用例设计的测试规划活动，并鼓励团队召开评审会议并确保纳入评审注释。</li>
<li>在测试周期中，通过不断评估分配给每个资源的工作并根据需要重新平衡或重新分配它们来监视测试进度。</li>
<li>检查在实现时间表方面是否有任何延迟，并与测试人员进行讨论，以找出他们可能面临的问题，并努力解决这些问题。</li>
<li>在测试团队中召开会议，以确保每个人都知道其他团队成员在做什么。</li>
<li>向利益相关者和管理层展示及时的状态，并灌输对正在完成的工作的信心。</li>
<li>如果预见到任何延迟，请准备任何风险缓解计划。</li>
<li>弥合测试团队和管理层之间的任何差距和差异，以形成一个干净的双向接口通道。</li>
</ol>
<h5 id="测试管理"><a href="#测试管理" class="headerlink" title="测试管理"></a>测试管理</h5><p>虽然领导力可能意味着一个完整的领域，如权力、知识、主动性、直觉、影响决策的能力等，但很多时候，即使某些测试领导者天生就具备几乎所有这些品质，但由于他们试图带出这些品质的方式，他们仍然可能远离有效管理测试团队的目标。</p>
<p>通常在测试团队中，尽管领导力和管理是相辅相成的，但它们绝对不是一回事。</p>
<p>考试领导者可能拥有纸面上的所有领导技能，但这并不意味着他也可以管理团队。我们为测试过程本身设置了几个策略。然而，测试团队管理的艺术在为管理定义硬性规则方面通常是一个灰色地带。</p>
<p>关于为什么会这样，以及任何测试团队与其他团队有何不同，您有什么想法？</p>
<p>我认为，认识到测试团队使用理论上完美且经过验证的管理方法非常重要，它可能并不总是运作良好。</p>
<h5 id="有效管理测试团队需要考虑的重要事项"><a href="#有效管理测试团队需要考虑的重要事项" class="headerlink" title="有效管理测试团队需要考虑的重要事项"></a>有效管理测试团队需要考虑的重要事项</h5><p>为了有效地管理测试团队，需要考虑某些事实。</p>
<h6 id="1-了解测试人员"><a href="#1-了解测试人员" class="headerlink" title="1.了解测试人员"></a>1.了解测试人员</h6><p>测试人员的工作是发现软件中的缺陷或错误，以提高其质量。在团队中，可能会有测试人员绝对喜欢通过引入创新和创造性的测试风格来破解代码。毋庸置疑，这需要一个人具有技能，创造力和那种看待软件的心态，这种心态与其他人完全不同。</p>
<p>由于在日常生活中花费了大量的工作时间和不断增长的经验，测试资源几乎无法打破这种”测试”心态，它成为他们个人的一部分，在个人和专业上。他们几乎在从产品到流程，测试线索，经理等各个方面寻找缺陷。</p>
<p>花时间了解测试团队的这种心态是能够为测试主管派生合理的测试管理方法的第一步，也是最重要的一步。</p>
<h6 id="2-测试人员的工作环境"><a href="#2-测试人员的工作环境" class="headerlink" title="2.测试人员的工作环境"></a>2.测试人员的工作环境</h6><p>测试团队最常发现自己面临着很大的压力，因为对于使用给定的测试资源需要完成的大量测试有严格的截止日期。</p>
<p>有时，由于无数因素，在将代码交付给测试团队时可能会出现延迟，或者在获取所需环境时出现延迟，或者在修复&#x2F;验证缺陷时出现延迟。所有这一切，在时间表中没有扩展。</p>
<p>除此之外，可能需要大量的测试工作，因此测试不足或不完整可能会直接引起对产品质量的问题。</p>
<p>尽管测试团队可能会主动标记他们识别的某些风险，但很多时候，管理层可能不会非常积极地看待这一点，因为他们可能不完全了解所涉及的细节，或者他们可能会将其视为测试团队缺乏技能水平。</p>
<p>毫无疑问，测试团队会经历高度的挫败感以及按时交付的压力。衡量测试团队经常接触的环境，在其中工作对于测试主管&#x2F;经理进行有效管理可能是宝贵的投入。</p>
<h6 id="3-测试团队的角色"><a href="#3-测试团队的角色" class="headerlink" title="3.测试团队的角色"></a>3.测试团队的角色</h6><p>在测试领域工作了很多年后，意识到，再多的测试都不是”完整”的测试，发现”所有”缺陷是一种虚构的现象。</p>
<p>很多时候，无论进行大量的测试工作，都会在客户或生产环境中发现缺陷，并被称为从测试团队中”逃脱”。测试团队经常会受到此类逃生的打击，并被要求定量描述他们的测试覆盖范围，以破译此现场问题是否可能在测试周期中被捕获。</p>
<p>有时，这会让测试人员对如何根据自己的技能向他人描绘他们的角色感到非常失望，因此在更广泛的图景中，他们自己也是如此。</p>
<p>结论</p>
<p>了解测试团队中的所有这些现实将有助于<strong>设定要遵循的管理方法</strong>类型，这意味着很有可能摆脱标准和理论管理技术。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/4b7f751c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/4b7f751c.html" class="post-title-link" itemprop="url">数据库测试指北</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 08:11:30" itemprop="dateCreated datePublished" datetime="2022-02-25T08:11:30+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数据库在软件应用程序中是无法避免的部分之一。</p>
<p>不管是web，桌面应用，移动端，B2B，B2C等，数据库在后端都是必需的。随着应用程序复杂程度的增加，对更强大更安全的数据库需求也随之增加。对于具有高交易频率的应用来说功能齐全的数据库的必要性是耦合的。</p>
<h4 id="为什么是数据库？"><a href="#为什么是数据库？" class="headerlink" title="为什么是数据库？"></a>为什么是数据库？</h4><p>下面会看到为什么要验证数据库的以下方面：</p>
<h5 id="①数据映射"><a href="#①数据映射" class="headerlink" title="①数据映射"></a>①数据映射</h5><p>在软件系统中，数据一般是在UI和后端数据库中来回传输，因为需要注意一下方面：</p>
<ul>
<li>检查UI、前端表单中的字段是否与数据表中的字段一直映射。通常映射信息在需求文档中定义；</li>
<li>当应用程序在前段执行某个操作时，都会在后端调用相应的CURD操作。作为测试人员必须检查是否正确的调用以及调用操作本身是否成功。</li>
</ul>
<h5 id="②ACID属性验证"><a href="#②ACID属性验证" class="headerlink" title="②ACID属性验证"></a>②ACID属性验证</h5><p>原子性、一致性、隔离性和持久性。数据库执行的每个事务都必须遵守这四个属性。</p>
<p><img src="/Echo/posts/4b7f751c/DB-Testing.jpg" alt="DB-Testing"></p>
<ul>
<li>原子性：事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li>一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li>
<li>隔离性：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li>持久性：事务一旦提交完成，任何外部因素（断电&#x2F;崩溃）都不能改变它。</li>
</ul>
<h5 id="③数据完整性"><a href="#③数据完整性" class="headerlink" title="③数据完整性"></a>③数据完整性</h5><p>对于任何CURD操作，共享数据更新的最新值&#x2F;状态都应显示在所有窗体和屏幕上。不应一个显示最新值一个显示比较旧的值。</p>
<p>C：创建–用户保存任何新的事务时，执行创建操作</p>
<p>R：检索–用户搜索或者查看任何已经保存的交易时，执行检索操作</p>
<p>U：更新–用户编辑或者修改现有记录时，执行更新操作</p>
<p>D：删除–用户从系统中删除任何记录时，执行删除操作</p>
<p>用户执行的任何数据库操作始终是以上四个操作之一。在设计数据库测试用例的方式包括检查数据在所有看起来的位置，以查看它是否始终相同。</p>
<h5 id="④业务规则一致性"><a href="#④业务规则一致性" class="headerlink" title="④业务规则一致性"></a>④业务规则一致性</h5><p>数据库中更复杂的组件意味着更复杂的组件，如关系约束、触发器、存储过程等。因此，测试人员必须提出适当的SQL查询才能验证这些复杂的对象。</p>
<h4 id="数据库测试清单"><a href="#数据库测试清单" class="headerlink" title="数据库测试清单"></a>数据库测试清单</h4><h5 id="1、事务"><a href="#1、事务" class="headerlink" title="1、事务"></a>1、事务</h5><p>测试事务时，确保满足ACID属性。</p>
<h5 id="2、数据库架构"><a href="#2、数据库架构" class="headerlink" title="2、数据库架构"></a>2、数据库架构</h5><ul>
<li>确定数据库运行所依据的要求。样品要求：<ul>
<li>在创建任何其他字段之前要创建的主键。</li>
<li>外键应完全索引，以便于检索和搜索。</li>
<li>字段名称以某些字符开头或结尾。</li>
<li>具有某些值可以或不能插入的约束的字段。</li>
</ul>
</li>
<li>根据相关性使用下列方法之一：<ul>
<li>SQL 查询 *DESC&lt;表名称&gt;*以验证架构。</li>
<li>用于验证各个字段的名称及其值的正则表达式</li>
<li>SchemaCrawler 等工具</li>
</ul>
</li>
</ul>
<h5 id="3、-触发器"><a href="#3、-触发器" class="headerlink" title="3、 触发器"></a>3、 触发器</h5><p>当某个事件发生在某个表上时，可以自动指示执行一段代码（触发器）。</p>
<p><strong>例如，</strong>一名新学生加入了一所学校。学生正在上2节课：数学和科学。学生将被添加到”学生表”中。一旦学生被添加到学生表中，触发器就可以将他添加到相应的主题表中。</p>
<p>测试的常用方法是首先独立执行触发器中嵌入的 SQL 查询并记录结果。接下来，将触发器作为一个整体执行。比较结果。</p>
<p>这些测试在黑盒和白盒测试阶段进行。</p>
<ul>
<li><strong>白盒测试</strong>：存根和驱动程序用于插入、更新或删除会导致触发器被调用的数据。基本思想是，即使在与前端（UI）集成之前，也只需单独测试数据库。</li>
<li><strong>黑盒测试</strong>:</li>
</ul>
<p><strong>a）</strong> 由于 UI 和 DB，集成现在可用;我们可以以调用触发器的方式从前端插入&#x2F;删除&#x2F;更新数据。之后，Select 语句可用于检索数据库数据，以查看触发器是否成功执行了预期的操作。</p>
<p><strong>b）</strong> 测试这一点的第二种方法是直接加载将调用触发器的数据，并查看它是否按预期工作。</p>
<h5 id="4、-存储过程"><a href="#4、-存储过程" class="headerlink" title="4、 存储过程"></a>4、 存储过程</h5><p>存储过程或多或少类似于用户定义的函数。这些语句可以通过调用过程&#x2F;执行过程语句调用，并且输出通常采用结果集的形式。</p>
<p>它们存储在 RDBMS 中，可用于应用程序。</p>
<p><strong>这些也在以下时间进行测试：</strong></p>
<ul>
<li><strong>白盒测试：</strong>存根用于调用存储过程，然后根据预期值验证结果。</li>
<li><strong>黑盒测试：</strong>从应用程序的前端 （UI） 执行操作，并检查存储过程的执行及其结果。</li>
</ul>
<h5 id="5、字段约束"><a href="#5、字段约束" class="headerlink" title="5、字段约束"></a>5、字段约束</h5><p><strong>默认值、唯一值和外键：</strong></p>
<ul>
<li>执行执行数据库对象条件的前端操作</li>
<li>使用 SQL 查询验证结果。</li>
</ul>
<p>检查某个字段的默认值非常简单。它是业务规则验证的一部分。您可以手动执行此操作，也可以使用QTP等工具。您可以手动执行一项操作，该操作将从前端添加字段默认值以外的值，并查看它是否会导致错误。</p>
<h4 id="数据库测试活动"><a href="#数据库测试活动" class="headerlink" title="数据库测试活动"></a>数据库测试活动</h4><h5 id="1）-确保数据映射："><a href="#1）-确保数据映射：" class="headerlink" title="#1） 确保数据映射："></a><strong>#1） 确保数据映射：</strong></h5><p>数据映射是数据库中的关键方面之一，每个软件测试人员都应该对其进行严格的测试。</p>
<p>确保AUT与其数据库的不同表单或屏幕之间的映射不仅准确，而且符合设计文档（SRS &#x2F; BRS）或代码。基本上，您需要验证每个前端字段与其相应的后端数据库字段之间的映射。</p>
<p>对于所有 CRUD 操作，请验证当用户从应用程序的 GUI 中单击”保存”、”更新”、”搜索”或”删除”时，是否更新了相应的表和记录。</p>
<p><strong>您需要验证的内容：</strong></p>
<ul>
<li>表映射、列映射和数据类型映射。</li>
<li>查找数据映射。</li>
<li>在 UI 上为每个用户操作调用正确的 CRUD 操作。</li>
<li>CRUD 操作成功。</li>
</ul>
<h5 id="2）确保事务的ACID属性："><a href="#2）确保事务的ACID属性：" class="headerlink" title="#2）确保事务的ACID属性："></a><strong>#2）确保事务的ACID属性：</strong></h5><p>DB Transactions的ACID属性<strong>是指”原子</strong>性”，”Consistency”，”<strong>Isolation</strong>“和”<strong>Durability</strong>“。在数据库测试活动期间，必须对这四个属性进行适当的测试。您需要验证每个事务是否都满足数据库的 ACID 属性。</p>
<p><img src="/Echo/posts/4b7f751c/ACID-Properties.jpg" alt="ACID-Properties"></p>
<p><strong>让我们通过下面的SQL代码举一个简单的例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE acidtest (A INTEGER, B INTEGER, CHECK (A + B = 100));</span><br></pre></td></tr></table></figure>

<p>ACID测试表将有两列 - A和B。存在一个完整性约束，即 A 和 B 中的值之和应始终为 100。</p>
<p><strong>原子性测试</strong>将确保在此表上执行的任何事务都是全部或无，即如果事务的任何步骤失败，则不会更新任何记录。</p>
<p><strong>一致性测试</strong>将确保每当更新列 A 或 B 中的值时，总和始终保持为 100。如果总和不是 100，则不允许在 A 或 B 中插入&#x2F;删除&#x2F;更新。</p>
<p><strong>隔离测试</strong>将确保如果两个事务同时发生并尝试修改ACID测试表的数据，则这些牵引力是孤立执行的。</p>
<p><strong>耐久性测试</strong>将确保一旦提交了此表上的事务，即使发生断电、崩溃或错误，它仍将保持这种状态。</p>
<p>如果您的应用程序正在使用分布式数据库，则需要进行更严格、彻底和敏锐的测试。</p>
<p><strong>#3） 确保数据完整性</strong></p>
<p>考虑应用程序的不同模块（即屏幕或表单）以不同的方式使用相同的数据，并对数据执行所有CRUD操作。</p>
<p>在这种情况下，请确保在各处都反映最新的数据状态。系统必须在所有表单和屏幕上显示更新和最新的值或此类共享数据的状态。这称为数据完整性。</p>
<p><img src="/Echo/posts/4b7f751c/di.jpg" alt="di"></p>
<p><strong>验证数据库数据完整性的测试用例：</strong></p>
<ul>
<li>检查是否所有触发器都已就位以更新引用表记录。</li>
<li>检查每个表的主要列中是否存在任何不正确&#x2F;无效的数据。</li>
<li>尝试在表中插入错误的数据，并观察是否发生任何故障。</li>
<li>检查在插入父级之前尝试插入子项会发生什么情况（尝试使用主键和外键）。</li>
<li>测试在删除仍由任何其他表中的数据引用的记录时是否发生任何故障。</li>
<li>检查复制的服务器和数据库是否同步。</li>
</ul>
<p><strong>#4）确保已实现的业务规则的准确性：</strong></p>
<p>如今，数据库不仅仅用于存储记录。事实上，数据库已经发展成为非常强大的工具，为开发人员在数据库级别实现业务逻辑提供了充分的支持。</p>
<p>强大功能的一些简单示例包括”参照完整性”、关系约束、触发器和存储过程。</p>
<p>因此，使用 DB 提供的这些功能和许多其他功能，开发人员可以在 DB 级别实现业务逻辑。测试人员必须确保实现的业务逻辑正确且工作准确。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/48610.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/48610.html" class="post-title-link" itemprop="url">什么是Kubernetes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-19 01:46:10" itemprop="dateCreated datePublished" datetime="2022-02-19T01:46:10+08:00">2022-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>近期开始学习Kubernetes，后续会将学习中整理的一些知识通过QA的方式记录在个人博客中。后续文章中Kubernetes简称为K8S。</p>
<h5 id="Q1、K8S是什么？"><a href="#Q1、K8S是什么？" class="headerlink" title="Q1、K8S是什么？"></a>Q1、K8S是什么？</h5><p>K8S是基于容器技术的分布式架构领先方案。它是谷歌十几年以来大规模应用容器化技术的经验积累和升华的重要成果。K8S是站Brog系统的肩膀上，汲取了brog过去的经验与教训，所以K8S现世时，让一众架构师为之疯狂。</p>
<h5 id="Q2、系统设计遵循了K8S的设计思想会带来什么？"><a href="#Q2、系统设计遵循了K8S的设计思想会带来什么？" class="headerlink" title="Q2、系统设计遵循了K8S的设计思想会带来什么？"></a>Q2、系统设计遵循了K8S的设计思想会带来什么？</h5><p>传统系统架构中和业务没有多大关系的底层代码或功能模块，都将消失在眼前，也不需要花费时间在负载均衡器的选型和部署实施问题，不需要考虑服务治理框架，不必在为服务监控和故障处理模块的开发而头疼。业内认为使用K8S可以减少30%，可以将精力更集中于业务本身，同时K8S提供了强大的自动化机制，后期的运维难度和运维成本大大降低。</p>
<h5 id="Q3、K8S有语言限制吗？"><a href="#Q3、K8S有语言限制吗？" class="headerlink" title="Q3、K8S有语言限制吗？"></a>Q3、K8S有语言限制吗？</h5><p>K8S没有语言限制，是一个开放的平台。不局限于任何一种语言，没有限定编程接口。不管使用什么语言编写的服务都可以映射在K8S的service里面，通过标准的TCP协议进行交互。K8S平台对现有的编程语言、编程框架、中间件没有任何侵入性。</p>
<h5 id="Q4、K8S有什么功能？"><a href="#Q4、K8S有什么功能？" class="headerlink" title="Q4、K8S有什么功能？"></a>Q4、K8S有什么功能？</h5><p>K8S有完备的集群管理能力，有多层次的安全防护和准入机制、多租用应用支撑、透明的服务注册、服务发现机制、自能负载均衡器、故障发现和自我修复能力、服务滚动升级、在线扩容、资源自动调度、多粒度资源配额管理能力。</p>
<h5 id="Q5-K8S会带来什么好处？"><a href="#Q5-K8S会带来什么好处？" class="headerlink" title="Q5 K8S会带来什么好处？"></a>Q5 K8S会带来什么好处？</h5><p>① 复杂系统可以模块化开发。以前很多技术大牛一起分工协作完成的分布式系统，现在仅需要一个架构师负责服务中组件的设计，几个业务人员负责业务代码开发，一个运维负责部署服务到K8S上，其他的K8S会帮我们完成。</p>
<p>②我们可以全面的拥抱微服务架构。微服务架构的核心是将一个巨大的单体应用分解为很多小的互相连接的微服务，一个微服务可能由多个实例副本支撑，副本的数量可以随着系统的负荷变化进行调整。微服务架构使得每个服务都可以独立开发、升级和扩展，因此系统具备很高的稳定性和快速迭代能力，开发者也可以自由选择开发技术。</p>
<p>③可以随时将系统整体的搬到云上。K8S的架构方案中完全屏蔽了底层网络的细节，基于Service的虚拟IP地址（Cluster IP）的设计思路让架构与底层的硬件拓扑无关，无须改变运行期的配置文件，就能将系统从现有的物理机环境无缝迁移到云上。</p>
<p>④K8S内在弹性扩容机制轻松应对突发流量。12306会在节假日租用阿里云的服务进行扩容，来满足用户需求。</p>
<p>⑤K8S超强的横向扩容能力让竞争力大大提升。对于公司来说，用户规模等同于有价资产，基于此，横向扩容能力是衡量企业尤其是互联网企业的竞争力的关键指标。K8S提供的工具，不用修改代码，就能将一个K8S集群从只包含几个Node的小集群平滑扩展到拥有上百个Node的大集群，甚至可以在线完成集群扩容。只要微服务架构设计得合理，能够在多个云环境中进行弹性伸缩，系统就能够承受大量用户并发访问带来的巨大压力。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>K8S是一个全新的基于容器化的分布式架构解决方案，并且是一个一站式的完备的分布式系统开发和支撑平台。能让公司更加专注于业务，而减轻架构和运维的要求，缩短产品上线周期。</p>
<p>后续会介绍K8S的相关概念和术语。和大家一起来学习K8S。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/25505.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/25505.html" class="post-title-link" itemprop="url">接口测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-09 10:43:40" itemprop="dateCreated datePublished" datetime="2022-02-09T10:43:40+08:00">2022-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h4><p>当开发应用程序或者网站时，会有不同组件进行集成，集成并促进这些组件之间通信的连接成为接口。简而言之，接口是由一组命令，消息等组成的软件。这些不同组件之间的通信会影响整体性能，因此需要进行测试和验证。</p>
<h4 id="什么是接口测试？"><a href="#什么是接口测试？" class="headerlink" title="什么是接口测试？"></a>什么是接口测试？</h4><p>为验证接口功能而进行的测试称为接口测试</p>
<p><img src="/Echo/posts/25505/Interface-Testing-Flow.jpg" alt="Interface-Testing-Flow"></p>
<p>接口测试中常见的组件：</p>
<ul>
<li>web服务和应用程序之间的接口</li>
<li>数据库服务和应用程序之间的接口</li>
</ul>
<h4 id="我们何时以及如何测试接口？"><a href="#我们何时以及如何测试接口？" class="headerlink" title="我们何时以及如何测试接口？"></a>我们何时以及如何测试接口？</h4><p><img src="/Echo/nterface-Testing_component.jpg" alt="Interface-Testing_component"></p>
<p>接口测试的3个阶段</p>
<ol>
<li>配置</li>
</ol>
<p>开发配置完接口后，根据需求验证配置；</p>
<ol start="2">
<li>验证</li>
</ol>
<p>开发完成后，对接口进行验证，这一部分也可以作为单元测试来进行。</p>
<p>  3.维护</p>
<p>整个软件准备就绪，部署完成并正常工作后，需要监控性能，由于系统做出更改或者性能调整可能会引入一些新问题。</p>
<p>接口测试主要是为了：</p>
<ul>
<li>服务器执行是否正确</li>
<li>错误信息处理并正常展示</li>
<li>与服务器连接重置时检查结果</li>
<li>组建内部通信的安全性检查</li>
<li>网络故障对组件之间通信的影响</li>
</ul>
<h4 id="接口测试的类型"><a href="#接口测试的类型" class="headerlink" title="接口测试的类型"></a>接口测试的类型</h4><p>接口测试基本是在系统架构的消息传递层完成的，主要涉及使用json，XML，rest API，SOAP web。</p>
<p>接口测试一般涉及以下做法：</p>
<p>单元测试：测试每个单独操作的功能（函数）</p>
<p>功能测试：测试相关接口要实现的功能</p>
<p>负载测试：验证负载下接口的性能</p>
<p>安全测试：测试安全机制，包含渗透测试，访问控制，加密等</p>
<p>运行时错误检测：监视程序运行时资源的争用、泄漏等问题</p>
<p>工作流测试：接口引擎是否按照预期处理工作流</p>
<p>单个系统测试：验证每个系统可以独立运行</p>
<h4 id="接口测试中注意清单"><a href="#接口测试中注意清单" class="headerlink" title="接口测试中注意清单"></a>接口测试中注意清单</h4><ul>
<li>测试中应包含4XX和5XX错误，有助于验证客户端和服务端错误处理，显示适当消息而不是代码错误。</li>
<li>使用HTTP身份验证验证用户</li>
<li>验证API中常用的使用方法，如get，put，delete，post等</li>
<li>验证从json到xml格式的转换，反之亦然</li>
<li>验证接口上的批量操作是否在获取正确的预期结果</li>
<li>验证API时区与地理时区是否匹配</li>
<li>验证未经授权的访问是否报错</li>
<li>验证连接中断的处理</li>
<li>验证从程序中删除部分组件，接口不再与之发生交互</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/42873.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/42873.html" class="post-title-link" itemprop="url">手工测试如何过渡到自动化测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-06 21:44:55" itemprop="dateCreated datePublished" datetime="2022-02-06T21:44:55+08:00">2022-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/Echo/posts/42873/Transition-from-Manual-to-Automated-Testing-Banner.png" alt="Transition-from-Manual-to-Automated-Testing-Banner"></p>
<h4 id="手工测试与自动化测试的区别"><a href="#手工测试与自动化测试的区别" class="headerlink" title="手工测试与自动化测试的区别"></a>手工测试与自动化测试的区别</h4><p>手工测试：顾名思义就是测试人员自己手动执行所有测试步骤，以便在应用程序发布之前查找错误。</p>
<p>自动化测试：测试人员编写自动化脚本以自动化工具自动执行测试步骤。测试人员将测试脚本存储起来作为资产来进行重用，从而为重复执行节省大量时间和精力。</p>
<h4 id="为什么要从手工测试转到自动化测试"><a href="#为什么要从手工测试转到自动化测试" class="headerlink" title="为什么要从手工测试转到自动化测试"></a>为什么要从手工测试转到自动化测试</h4><p>自动化测试可以克服许多手工测试中遇到的挑战，在敏捷项目中尤为重要。</p>
<p>1、测试可重用性</p>
<p>自动化测试用例和测试套件可以在不同的测试周期和测试环境中多次重用。因此，每次应用程序更改时，您都可以运行自动回归测试套件来检查回归错误，从而避免重复手动执行回归测试。这是自动化降低操作故障风险的最重要优势之一。</p>
<p>2、更高的测试覆盖率</p>
<p>由于测试是自动执行的，因此有更多时间专注于新的测试方案，并编写更自动化的测试用例来验证和确认受测应用程序 （AUT）。可以自由地进行更多的探索性测试，以确保产品质量。</p>
<p>自动测试也可以在不同的平台和设备上同时或并行执行。执行的测试越多，意味着可能会发现更多的回归错误，并确认更多的业务需求。</p>
<p>3、更早的错误检测和反馈</p>
<p>在生产环境中发现的 Bug 在时间、金钱和精力等方面修复成本更高。这就是为什么团队正在向左移动，更早地发现错误以最大限度地降低成本。</p>
<p>如果自动化测试做得好，可以在开发阶段开始后立即开始。开发人员可以在将代码提交到版本控制系统之前在其本地计算机上执行单元测试。</p>
<p>单元测试也可以集成到 CI 管道中。提交代码后，将触发管道以运行自动化单元测试，然后运行集成或系统测试。通过这种方式，开发人员可以更快地接收反馈，检测和修复错误，防止bug潜入后期阶段。</p>
<p>4、超越手工测试</p>
<p>测试自动化可以完成手动测试可能难以实现的工作，特别是对于需要大量精力和资源（如性能测试）的特定测试。它可以模拟来自不同平台和设备对AUT服务器端的数千个同时请求，这几乎不可能手动完成。</p>
<p>在并行执行方面，自动化工具的工作速度比人类快，精度更高。机器不会像人类那样感到无聊或疲惫，可以避免类似人类的错误。因此，测试结果是可靠且快速接收的。（PS：要记住的一件事是，长远来看，自动化测试是有效的，但是自动化测试初始成本较高，需要时间和设备将所有内容落实到位，才会带来可观的效果并降低成本效益比）。</p>
<h4 id="什么情况不值得开展自动化测试？"><a href="#什么情况不值得开展自动化测试？" class="headerlink" title="什么情况不值得开展自动化测试？"></a>什么情况不值得开展自动化测试？</h4><p>以下四种情况，要开展自动化测试前请慎重、慎重、慎重考虑</p>
<ul>
<li>短期的项目</li>
<li>开发在4-6月内完成的简单应用程序</li>
<li>不经常运行测试</li>
<li>测试许多手工执行起来更容易的复杂方案</li>
</ul>
<h4 id="从手工测试过渡到自动化测试"><a href="#从手工测试过渡到自动化测试" class="headerlink" title="从手工测试过渡到自动化测试"></a>从手工测试过渡到自动化测试</h4><h5 id="Step1、设计自动化测试策略"><a href="#Step1、设计自动化测试策略" class="headerlink" title="Step1、设计自动化测试策略"></a>Step1、设计自动化测试策略</h5><p>许多团队通常都很挣扎，因为他们没有面向目标的测试自动化策略。它使所有团队成员都在同一页面上。它告知并传达预先定义的目标和计划，每个人都可以从中了解他们所做的事情是对还是错，并调整下一步行动。</p>
<p>如果没有清晰的愿景战略，团队很容易改变方向，选择错误的解决方案，并且无法以有助于实现业务价值的方式使用自动化测试。</p>
<p>自动化测试就像构建并拥有自己的软件来测试其他应用程序一样。它应该以与软件开发相同的方式以清晰的愿景和计划进行管理。</p>
<h5 id="Setp2、丰富自动化测试基础"><a href="#Setp2、丰富自动化测试基础" class="headerlink" title="Setp2、丰富自动化测试基础"></a>Setp2、丰富自动化测试基础</h5><p>了解测试自动化的所有基础知识至关重要，从敏捷和 DevOps 方法、框架构建、自动化金字塔、架构、自动化方法到报告和指标。没有良好的基础，团队几乎无法执行其战略。</p>
<p>此外，还应该检查特定的自动化解决方案或测试工具，它们需要哪些技能，它们解决了什么问题，以及它们在实践中是如何做到的。并保持学习过程不间断。</p>
<p>许多团队只是在一段时间后停止更新其知识库。随着新技术、新趋势和新解决方案的出现，行业发展迅速，停止学习和培训只能意味着落后于竞争对手。</p>
<h5 id="Step3、-编程技能"><a href="#Step3、-编程技能" class="headerlink" title="Step3、 编程技能"></a>Step3、 编程技能</h5><p>许多测试自动化解决方案需要编程技能来构建框架和编写自动化测试脚本。为了克服这些障碍，许多团队的目标是使用配备低代码功能的现成测试工具。</p>
<p>但是，没有编程技能，测试人员只能使用内置的关键字、录制和播放功能，或者具有直观 UI 的手动模式来创建自动测试。事情会永远这么简单吗？</p>
<p>从长远来看，要编写更复杂的测试用例、修改脚本、构建自定义关键字、维护测试或调试失败的测试，团队中至少应该有一个熟悉编码和编程的自动化测试人员或一个开发人员来支持。</p>
<p>因此，如果团队想要从手动测试切换到自动测试，请考虑雇用具有编程背景的测试人员，或者让团队成员学习和提高他们的编码技能。</p>
<h5 id="Step4、-选择适合自己的测试工具"><a href="#Step4、-选择适合自己的测试工具" class="headerlink" title="Step4、 选择适合自己的测试工具"></a>Step4、 选择适合自己的测试工具</h5><p>工具选择可能非常棘手，因为市场上有数千种可用选项。仅根据其他人的成功来选择他们的工具。但是，一个工具对其他工具有效并不一定意味着它对你有同样的作用。</p>
<p>考虑团队的特定需求和资源。也就是说，这里有一些问题需要评估和选择最合适的解决方案：</p>
<ul>
<li><strong>想解决什么问题？</strong>确定要应用自动测试的 AUT（Web、桌面或移动应用程序）以及所需的功能（用于测试创建、执行、报告等）。</li>
<li><strong>谁使用该工具？</strong> 如果他们是手动测试人员，那么低代码解决方案将更合适。</li>
<li><strong>能否融入团队的现有流程和工具链？</strong>寻找具有本机集成的自动化工具，以减少变通方法的时间。</li>
<li><strong>是否面向未来？</strong>为避免从一个工具切换到另一个工具，请考虑团队的可伸缩性，并选择可以满足未来需求的工具。</li>
<li><strong>预算是多少？</strong> 开源是免费的，但需要时间来设置和开发测试自动化工具，而商业工具可以快速启动且易于使用。</li>
<li><strong>从哪里可以获得支持？</strong>良好的客户支持或活跃的社区可以在处理技术问题时真正帮助您并节省时间。</li>
</ul>
<p><strong>提示</strong>：从手动起点开始，最好选择一个现成的工具，它具有低代码和脚本选项，如<a target="_blank" rel="noopener" href="https://www.softwaretestinghelp.com/katalon-studio-tutorial/">Katalon Studio</a>。它将为您节省大量时间来构建框架和功能，这是启动测试自动化时压力最大的部分。</p>
<p>借助”录制”和”回放”等低代码功能，手动测试人员可以快速开始自动执行测试用例并捕获测试对象。之后，当拥有更多的编码经验时，他们可以继续编写测试脚本，构建更多的自定义关键字，并利用更高级的功能。</p>
<p>选择工具后，请记住进行概念验证。在工具上运行快速冲刺，让所有团队成员参与进来。然后，在冲刺 （sprint） 结束时，收集所有反馈并评估该工具是否能够满足团队的所有标准要求。</p>
<h5 id="Setp5、-小demo运行，自信扩展"><a href="#Setp5、-小demo运行，自信扩展" class="headerlink" title="Setp5、 小demo运行，自信扩展"></a>Setp5、 小demo运行，自信扩展</h5><p>从小项目的特定小目标开始，例如在一段时间内达到某个自动化测试用例。保持错误小，从中吸取教训，并逐步扩大团队测试自动化的规模。不要因为过于雄心勃勃致使事情复杂化而延迟过渡。</p>
<h4 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h4><p>从手动自动化转向测试自动化可能是一个困难的长期过程。没有仔细的规划，缺乏所需的技能组合以及不合适的解决方案是导致团队挣扎的一些最常见的根本原因。欢迎在下边的讨论区我们一起交流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/Echo/archives/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/Echo/archives/page/5/">5</a><a class="extend next" rel="next" href="/Echo/archives/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">丑牛</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/Echo/js/comments.js"></script><script src="/Echo/js/utils.js"></script><script src="/Echo/js/motion.js"></script><script src="/Echo/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/Echo/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"hugfeature","repo":"myBlogTalk","client_id":"f4b1fae431a4943a75f3","client_secret":"2b6995c484ff0a0a920d65ac7fd5bb1bf13fb2f2","admin_user":null,"distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"62e7a0c6414fa96529635da1af7c9879"}</script>
<script src="/Echo/js/third-party/comments/gitalk.js"></script>

</body>
</html>
