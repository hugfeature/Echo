<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.0.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/Echo/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/Echo/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/Echo/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/Echo/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="5ZQ9pmEjPOsQmbBYQoUK41fLaMMyEK5pDRa34TE8fW4">
  <meta name="msvalidate.01" content="58AE2D56435A76DA1BF1341C2E6930C1">

<link rel="stylesheet" href="/Echo/css/main.css">



<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"hugfeature.github.io","root":"/Echo/","images":"/Echo/images","scheme":"Gemini","darkmode":false,"version":"8.9.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/Echo/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/Echo/js/config.js"></script>
<meta name="description" content="曾经梦想仗剑走天涯!因为遇见她，所以回了家！">
<meta property="og:type" content="website">
<meta property="og:title" content="测试的名义">
<meta property="og:url" content="https://hugfeature.github.io/Echo/archives/index.html">
<meta property="og:site_name" content="测试的名义">
<meta property="og:description" content="曾经梦想仗剑走天涯!因为遇见她，所以回了家！">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="丑牛">
<meta property="article:tag" content="大数据测试，性能测试，测试，自动化测试，K8S，Kubernetes，接口测试，测试管理，测试计划，测试策略">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://hugfeature.github.io/Echo/archives/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"archives/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>测试的名义 - Stay hungry, Stay foolish</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-SY6RK3NESF"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-SY6RK3NESF","only_pageview":false}</script>
  <script src="/Echo/js/third-party/analytics/google-analytics.js"></script>




  <script async src="https://www.clarity.ms/tag/myblog"></script>

  <noscript>
    <link rel="stylesheet" href="/Echo/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/Echo/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">测试的名义</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Stay hungry, Stay foolish</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home"><a href="/Echo/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li>
        <li class="menu-item menu-item-about"><a href="/Echo/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li>
        <li class="menu-item menu-item-categories"><a href="/Echo/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li>
        <li class="menu-item menu-item-commonweal"><a href="/Echo/404/" rel="section"><i class="fa fa-heartbeat fa-fw"></i>公益 404</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">丑牛</p>
  <div class="site-description" itemprop="description">曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-categories">
          <a href="/Echo/categories/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/Echo/tags/">
        <span class="site-state-item-count">57</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/hugfeature/" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hugfeature&#x2F;" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>
  <div class="cc-license site-overview-item animated" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" class="cc-opacity" rel="noopener" target="_blank"><img src="https://cdn.jsdelivr.net/npm/@creativecommons/vocabulary@2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></a>
  </div>



        </div>
      </div>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/hugfeature" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/c066093e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/c066093e.html" class="post-title-link" itemprop="url">大数据面试-HDFS</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-04-06 13:24:06" itemprop="dateCreated datePublished" datetime="2022-04-06T13:24:06+08:00">2022-04-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E5%A4%A7%E6%95%B0%E6%8D%AE/" itemprop="url" rel="index"><span itemprop="name">大数据</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="一、HDFS读写流程"><a href="#一、HDFS读写流程" class="headerlink" title="一、HDFS读写流程"></a>一、HDFS读写流程</h4><h5 id="①HDFS写流程"><a href="#①HDFS写流程" class="headerlink" title="①HDFS写流程"></a>①HDFS写流程</h5><p>1）client 客户端发送上传请求，通过 RPC 与 namenode 建立通信，namenode 检查该用户是否有上传权限，以及上传的文件是否在 hdfs 对应的目录下重名，如果这两者有任意一个不满足，则直接报错，如果两者都满足，则返回给客户端一个可以上传的信息。</p>
<p>2）client 根据文件的大小进行切分，默认 128M 一块，切分完成之后给namenode 发送请求第一个 block 块上传到哪些服务器上。</p>
<p>3）namenode 收到请求之后，根据网络拓扑和机架感知以及副本机制进行文件分配，返回可用的 DataNode 的地址</p>
<p>4）客户端收到地址之后与服务器地址列表中的一个节点如 A 进行通信，本质上就是 RPC 调用，建立 pipeline，A 收到请求后会继续调用 B，B 在调用 C，将整个 pipeline 建立完成，逐级返回 client。</p>
<p>5）client 开始向 A 上发送第一个 block（先从磁盘读取数据然后放到本地内存缓存），以 packet（数据包，64kb）为单位，A 收到一个 packet 就会发送给B，然后 B 发送给 C，A 每传完一个 packet 就会放入一个应答队列等待应答</p>
<p>6）数据被分割成一个个的 packet 数据包在 pipeline 上依次传输，在pipeline 反向传输中，逐个发送 ack（命令正确应答），最终由 pipeline 中第一个 DataNode 节点 A 将 pipelineack 发送给 Client。</p>
<p>7）当一个 block 传输完成之后, Client 再次请求 NameNode 上传第二个block ，namenode 重新选择三台 DataNode 给 client</p>
<h5 id="②HDFS读流程"><a href="#②HDFS读流程" class="headerlink" title="②HDFS读流程"></a>②HDFS读流程</h5><p>1）client 向 namenode 发送 RPC 请求。请求文件 block 的位置<br>2）namenode 收到请求之后会检查用户权限以及是否有这个文件，如果都符合，则会视情况返回部分或全部的 block 列表，对于每个 block，NameNode都会返回含有该 block 副本的 DataNode 地址； 这些返回的 DN 地址，会按照集群拓扑结构得出 DataNode 与客户端的距离，然后进行排序，排序两个规则：网络拓扑结构中距离 Client近的排靠前；心跳机制中超时汇报的 DN 状态为 STALE，这样的排靠后<br>3）Client 选取排序靠前的 DataNode 来读取 block，如果客户端本身就是DataNode,那么将从本地直接获取数据(短路读取特性)<br>4）底层上本质是建立 Socket Stream（FSDataInputStream），重复的调用父类 DataInputStream 的 read 方法，直到这个块上的数据读取完毕<br>5）当读完列表的 block 后，若文件读取还没有结束，客户端会继续向NameNode 获取下一批的 block 列表<br>6）读取完一个 block 都会进行 checksum 验证，如果读取 DataNode 时出现错误，客户端会通知 NameNode，然后再从下一个拥有该 block 副本的DataNode 继续读<br>7）read 方法是并行的读取 block 信息，不是一块一块的读取；NameNode只是返回 Client 请求包含块的 DataNode 地址，并不是返回请求块的数据<br>8） 最终读取来所有的 block 会合并成一个完整的最终文件</p>
<h4 id="二、HDFS-在读取文件的时候-如果其中一个块突然损坏了怎么办"><a href="#二、HDFS-在读取文件的时候-如果其中一个块突然损坏了怎么办" class="headerlink" title="二、HDFS 在读取文件的时候,如果其中一个块突然损坏了怎么办"></a>二、HDFS 在读取文件的时候,如果其中一个块突然损坏了怎么办</h4><p>客户端读取完 DataNode 上的块之后会进行 checksum 验证，也就是把客户端读取到本地的块与 HDFS 上的原始块进行校验，如果发现校验结果不一致，客户端会通知NameNode，然后再从下一个拥有该 block 副本的 DataNode 继续读。</p>
<h4 id="三、HDFS-在上传文件的时候-如果其中一个-DataNode-突然挂掉了怎么办"><a href="#三、HDFS-在上传文件的时候-如果其中一个-DataNode-突然挂掉了怎么办" class="headerlink" title="三、HDFS 在上传文件的时候,如果其中一个 DataNode 突然挂掉了怎么办"></a>三、HDFS 在上传文件的时候,如果其中一个 DataNode 突然挂掉了怎么办</h4><p>客户端上传文件时与 DataNode 建立 pipeline 管道，管道正向是客户端向DataNode 发送的数据包，管道反向是 DataNode 向客户端发送 ack 确认，也就是正确接收到数据包之后发送一个已确认接收到的应答，当 DataNode 突然挂掉了，客户端接收不到这个 DataNode 发送的 ack 确认，客户端会通知 NameNode，NameNode 检查该块的副本与规定的不符，NameNode 会通知 DataNode 去复制副本，并将挂掉的 DataNode 作下线处理，不再让它参与文件上传与下载。</p>
<h4 id="四、HDFS-的组织架构"><a href="#四、HDFS-的组织架构" class="headerlink" title="四、HDFS 的组织架构"></a>四、HDFS 的组织架构</h4><p>1）Client：客户端<br>（1）切分文件。文件上传 HDFS 的时候，Client 将文件切分成一个一个的 Block，然后进行存储<br>（2）与 NameNode 交互，获取文件的位置信息<br>（3）与 DataNode 交互，读取或者写入数据<br>（4）Client 提供一些命令来管理 HDFS，比如启动关闭 HDFS、访问 HDFS 目录及内容等<br>2）NameNode：名称节点，也称主节点，存储数据的元数据信息，不存储具体的数据<br>（1）管理 HDFS 的名称空间<br>（2）管理数据块（Block）映射信息<br>（3）配置副本策略<br>（4）处理客户端读写请求<br>3）DataNode：数据节点，也称从节点。NameNode 下达命令，DataNode 执行实际的操作<br>（1）存储实际的数据块<br>（2）执行数据块的读&#x2F;写操作<br>4）Secondary NameNode：并非 NameNode 的热备。当 NameNode 挂掉的时候，它并不能马上替换NameNode 并提供服务<br>（1）辅助 NameNode，分担其工作量<br>（2）定期合并 Fsimage 和 Edits，并推送给 NameNode<br>（3）在紧急情况下，可辅助恢复 NameNode</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/6baa0397.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/6baa0397.html" class="post-title-link" itemprop="url">Kubernetes--master、node</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-15 16:02:30" itemprop="dateCreated datePublished" datetime="2022-03-15T16:02:30+08:00">2022-03-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/kubernetes/" itemprop="url" rel="index"><span itemprop="name">kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="Master"><a href="#Master" class="headerlink" title="Master"></a>Master</h4><p> Kubernetes里的Master指的是集群控制节点，在每个Kubernetes集群里都需要有一个Master来负责整个集群的管理和控制，基本上Kubernetes的所有控制命令都发给它，它负责具体的执行过程，我们后面执行的所有命令基本都是在Master上运行的。Master通常会占据一个独立的服务器（高可用部署建议用3台服务器），主要原因是它太重要了，是整个集群的“首脑”，如果它宕机或者不可用，那么对集群内容器应用的管理都将失效。<br>在Master上运行着以下关键进程。</p>
<ul>
<li>Kubernetes API Server（kube-apiserver）：提供了HTTP Rest接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口，也是集群控制的入口进程。</li>
<li>Kubernetes Controller Manager（kube-controller-manager）：Kubernetes里所有资源对象的自动化控制中心，可以将其理解为资源对象的“大总管”。</li>
<li>Kubernetes Scheduler（kube-scheduler）：负责资源调度（Pod调度）的进程，相当于公交公司的“调度室”。另外，在Master上通常还需要部署etcd服务，因为Kubernetes里的所有资源对象的数据都被保存在etcd中。</li>
</ul>
<h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><p>除了Master，Kubernetes集群中的其他机器被称为Node，在较早的版本中也被称为Minion。与Master一样，Node可以是一台物理主机，也可以是一台虚拟机。Node是Kubernetes集群中的工作负载节点，每个Node都会被Master分配一些工作负载（Docker容器），当某个Node宕机时，其上的工作负载会被Master自动转移到其他节点上。<br>在每个Node上都运行着以下关键进程。</p>
<ul>
<li>kubelet：负责Pod对应的容器的创建、启停等任务，同时与Master密切协作，实现集群管理的基本功能</li>
<li>kube-proxy：实现Kubernetes Service的通信与负载均衡机制的重要组件。</li>
<li>Docker Engine（docker）：Docker引擎，负责本机的容器创建和管理工作。</li>
</ul>
<p>Node可以在运行期间动态增加到Kubernetes集群中，前提是在这个节点上已经正确安装、配置和启动了上述关键进程，在默认情况下kubelet会向Master注册自己，这也是Kubernetes推荐的Node管理方式。一旦Node被纳入集群管理范围，kubelet进程就会定时向Master汇报自身的情报，例如操作系统、Docker版本、机器的CPU和内存情况，以及当前有哪些Pod在运行等，这样Master就可以获知每个Node的资源使用情况，并实现高效均衡的资源调度策略。而某个Node在超过指定时间不上报信息时，会被Master判定为“失联”，Node的状态被标记为不可用<br>（Not Ready），随后Master会触发“工作负载大转移”的自动流程。</p>
<p>可以通过kubectl get nodes查看集群中有多少个node，然后可以通过kubectl describe node <node_ name>来查看某个node的具体信息。describe展示node的关键信息如下：</node_></p>
<ul>
<li>Node的基本信息：名称、标签、创建时间等。</li>
<li>Node当前的运行状态：Node启动后会做一系列的自检工作，比如磁盘空间是否不足（DiskPressure）、内存是否不足（MemoryPressure）、网络是否正常（NetworkUnavailable）、PID资源是否充（PIDPressure）。在一切正常时设置Node为Ready状态（Ready&#x3D;True），该状态表示Node处于健康状态，Master将可以在其上调度新的任务了（如启动Pod）。</li>
<li>Node的主机地址与主机名。</li>
<li>Node上的资源数量：描述Node可用的系统资源，包括CPU、内存数量、最大可调度Pod数量等。</li>
<li>Node可分配的资源量：描述Node当前可用于分配的资源量。</li>
<li>主机系统信息：包括主机ID、系统UUID、Linux  kernel版本号、操作系统类型与版本、Docker版本号、kubelet与kube-proxy的版本号等。</li>
<li>当前运行的Pod列表概要信息。</li>
<li>已分配的资源使用概要信息，例如资源申请的最低、最大允许使用量占系统总量的百分比。</li>
<li>Node相关的Event信息。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/82ff0530.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/82ff0530.html" class="post-title-link" itemprop="url">成为高效的测试主管</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 22:42:40" itemprop="dateCreated datePublished" datetime="2022-03-01T22:42:40+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>如何成为高效的测试主管，打造一个更快乐、更成功的测试团队</p>
<h4 id="技能1-具备业务知识和技术技能"><a href="#技能1-具备业务知识和技术技能" class="headerlink" title="技能1  具备业务知识和技术技能"></a>技能1  具备业务知识和技术技能</h4><ul>
<li><p>一个组织通常会提出其业务目标，这些目标从更高级别的管理层一直转化为每个团队和个人。测试主管必须对项目路线图、总体组织目标、利益干系人和客户需求有良好的控制。在任何给定的时刻，他们必须能够提供任何测试团队成员所需的指导，以帮助他们了解他&#x2F;她正在扮演什么角色，以符合项目的成功，并且必须使他们能够看到更大的图景。</p>
</li>
<li><p>大多数情况下，测试人员发现测试主管可能无法完全理解他们在测试时面临的技术问题。测试主管必须具备所需的技能，以便能够使用任何工具，环境，系统等指导测试人员，并提供解决方案以克服他们可能面临的任何问题。在关键时刻，他们还必须自己承担一些工作，以减轻团队的负担。</p>
</li>
<li><p>业务本质上是非常动态的，很多时候，新的测试项目可能会在发布结束时添加。有时，已经测试过的项目可能会取消范围。在这两种情况下，测试主管必须指导测试人员，使他们能够客观地查看范围变化。测试线索的这种能力能够在技术上和其他方面指导团队，这将有助于团队成员依赖测试线索。</p>
</li>
</ul>
<h4 id="技能2-工作量估算和有效分配工作"><a href="#技能2-工作量估算和有效分配工作" class="headerlink" title="技能2 工作量估算和有效分配工作"></a>技能2 工作量估算和有效分配工作</h4><ul>
<li><p>当需求文档浮出水面时，测试主管和他的测试人员团队将编写测试计划，该计划将定义范围，硬件，软件，要测试的功能，计划等。在此基础上，对所需工作量进行规模估计，并进行适当的工作分配。</p>
</li>
<li><p>在测试团队中，有一些资深人士和一些初级人士。必须通过评估每个测试人员的利益来进行仔细的评估。任务必须使他们获得的工作不仅要让他们兴奋，还要建立在他们现有的知识库之上。</p>
</li>
<li><p>测试团队中的另一个常见问题是工作负载平衡。繁重的工作量是测试团队的重要组成部分，不断推动您的团队加班可能会导致饱和。如果潜在客户检测到可能存在繁重的工作负载，必须由更少的资源来覆盖，则必须尽早制定适当的缓解计划。在某些不可避免的情况下，必须随时向团队发布这是不可预见的情况，并且非常感谢他们愿意扩展。</p>
</li>
<li><p>其次，即使具有丰富经验的高级测试人员可以涵盖各种各样的行项目，但向他们施加更多的工作和责任肯定会阻止他们完成测试目标的兴趣。承担一些经过计算的风险，并将具有挑战性的物品分配给初级会员。他们渴望了解和成长，这可能有助于发展团队。</p>
</li>
</ul>
<h4 id="技能3-尽量不要过度提交"><a href="#技能3-尽量不要过度提交" class="headerlink" title="技能3 尽量不要过度提交"></a>技能3 尽量不要过度提交</h4><ul>
<li>通常，测试领导者，为了突出团队的技能，通过过度投入来给团队带来压力。现在，过度承诺可能意味着一个广泛的领域。</li>
</ul>
<p>例：如果在测试团队开始测试时测试范围发生了变化，并且认为测试内容增加。在这种情况下，当测试主管被要求提供有关尺寸和完成所需时间的输入时，往往会过度承诺他们可以花费更长的时间&#x2F;周末，并在相同的持续时间内”挤压”测试，而不会影响质量。这不仅设定了一个永久的期望，即测试团队将始终扩展自己，而且还迫使他们做出很多个人牺牲。</p>
<ul>
<li><p>在某些其他时候，过度投入可能意味着在发现缺陷&#x2F;逃避方面对测试团队设定不合理的期望。了解测试人员是人类，容易出错的基本事实至关重要。因此，设置过度不切实际的目标，即可以忽略不计&#x2F;没有缺陷逃逸是令人沮丧的，因为测试人员往往会对测试团队之外可能发现的任何缺陷负责。</p>
</li>
<li><p>过度投入会导致倦怠。在前一种情况下，测试范围发生变化，请与管理层进行相应的测试计划协商。在后一种情况下，要明白生活中没有什么是没有错误的，设定这样的目标只有在理论上听起来很棒。</p>
</li>
</ul>
<h4 id="技能4-各级沟通，人际交往能力"><a href="#技能4-各级沟通，人际交往能力" class="headerlink" title="技能4 各级沟通，人际交往能力"></a>技能4 各级沟通，人际交往能力</h4><p>无论是通过电子邮件，电话还是人际关系层面的沟通都应该是清单上的第一项，但就像它所说 - 将最好的留到最后。让我们来看看这如何影响几乎所有的技术和非技术方面。</p>
<p><strong>了解如何提出异议：</strong></p>
<p>作为测试主管，你是管理层和测试团队之间的接口。实际上没有”格式”可以与任何一方意见相左，但是当情况需要时，必须这样做。当然，有办法做到这一点。当涉及到测试人员时，您需要采取更敏感或更柔和的方法。</p>
<p>说到管理，你可能必须让他们看到你的想法的价值，而不是他们的事实信息。</p>
<p><strong>谈判技巧</strong>:</p>
<p>测试项目总是有一系列挑战，如环境问题，管理对测试进度的关注，管理层和各个团队之间对目标的理解不同，团队成员内部以及团队成员与管理层之间的人际关系问题&#x2F;冲突。在这种时候，测试领导者很难通过这些挑战看到光明。</p>
<p>有时高层不是很容易打交道，因此重要的是要以一种让另一方觉得他们的意见得到了考虑的方式进行谈判。同样，领导必须能够推动冲突的解决，其中双方都认为中间立场是他们可以同意的。</p>
<p><strong>鼓励与开发协作</strong>:</p>
<p>通常，当开发团队拒绝限制的缺陷时，测试人员会感到沮丧。虽然他们每个人都来自他们来自哪里，但这往往会导致测试和开发之间的”我们vs他们”的态度。测试负责人应推动测试团队与开发建立健康和协作的关系。</p>
<p><strong>将看到的两个好处：</strong></p>
<ul>
<li>测试人员可以更好地了解该功能的背景及其局限性和</li>
<li>开发人员了解最终用户如何看待代码。</li>
</ul>
<p><strong>向上级管理层报告和电子邮件通信：</strong></p>
<p>测试主管的很大一部分时间用于准备状态报告并向管理层报告进度。领导者是管理团队看到测试团队努力的窗口，因此他必须能够以清晰易懂的方式报告信息。</p>
<p>报告必须非常清楚地突出测试人员的成就，以使管理层能够立即意识到这一点。它还应该描述测试团队面临的问题，团队已经尝试或将要尝试的一系列事情，以解决这个问题，并且在超出他们控制范围的情况下，清楚地说明这一点 - 要求管理层指导解决。</p>
<p>即使测试团队的进度达不到标准，领导也必须能够向管理层灌输信心，即测试团队正在以最佳质量执行以满足最后期限。</p>
<p><strong>团队会议：</strong></p>
<p>毋庸置疑，测试负责人必须推动内部会议。这些会议将使他能够了解每个测试人员的任务，他当前的进展以及阻碍他进步的问题。牵头人应讨论与根本原因接近的问题，并就如何克服这些问题提出建议&#x2F;方法。</p>
<p>这个论坛也可以用来向团队成员传递赞赏或赞美，鼓励他们表现得更好，激励他人。偶尔发一封电子邮件来感谢他们的贡献，这是一个非常好的主意，可以让测试人员保持动力，让他们表现出色！</p>
<p>团队会议还可以使测试负责人确保测试人员在测试基础架构、项目清晰度、开发支持良好的缺陷周转时间等方面拥有他们所需要的东西。</p>
<p>团队会议形成了一个很好的平台来举行头脑风暴会议，其输出可以导致创新，流程改进，以执行日常工作。</p>
<p>除了技术方面，团队会议还使测试负责人能够与记者建立健康的关系。反过来，这也可以证明是他的一种学习，通过定期询问如何更好地管理的反馈。口头禅很简单：你成长，我成长！</p>
<p><strong>提供空间：</strong></p>
<p>特别是测试团队主要由不同的人员组成，每个人员都有自己的工作风格。大多数测试主管经常犯一个错误，即试图在团队中强制实施统一的文化，而这种文化在过去可能对他很有效。基本规则是让人们做自己的事情，除非它严重阻碍了项目进度。</p>
<p>在关键的里程碑日期 - 如果要求测试团队必须工作到很晚，周末才能满足时间表，给他们空间和自由，以他们希望的方式工作，这是最重要的。为每个人提供备份，以便让人们在需要的时候休息一下是可以的。</p>
<p>还要向他们保证，一旦达到最后期限，他们可以花一些时间充电。</p>
<p>特别是在一个成熟的测试团队中，几乎所有资源都有相当多的经验和可信度，强迫某些管理文化会导致公开的分歧和争论。了解团队在技术上所做的工作，提出有价值的建议，并让他们采取实现里程碑所需的东西。</p>
<p>不要时不时地出现在他们的办公桌前要求更新状态。这给这个人带来了很大的压力，如果他那天无法克服某个特定问题，就会有一种失败&#x2F;怨恨的感觉。</p>
<p>在命令中做第二个:</p>
<p>任何领导者的首要目标必须是创造火炬手;即创造其他领导者。事实上，这是优秀领导者最独特的品质之一。对于初级成员来说，虽然敏锐地回顾他们正在做的事情很重要，但如果他们被允许承认自己的角色，这对他们来说将是无价的学习。</p>
<p><strong>例如，</strong>如果他们在测试时遇到问题，使他们能够进行研究，跟进开发并推动其独立完成，除非有必要进行干预。这将有助于他们的成长。</p>
<p>与高级成员一起 - 让他们参与关键决策活动。他们的经验可以被证明是一种资产，所以要好好利用它。确保他们被投射为自己的领导者，将你自己的部分责任委托给他们。通过制作一个伙伴系统来授权他们指导初级成员，这将平等地帮助两个成员。</p>
<p><strong>电子邮件通信：</strong></p>
<p>这可能应该是这里几乎所有项目的子弹，也是企业领域任何个人的必备品质，更不用说领导者了。无论是准备报告，演讲，审查过程，传递赞赏等，拥有良好的沟通技巧对于有效表达自己至关重要。</p>
<h4 id="技能5-个人品质"><a href="#技能5-个人品质" class="headerlink" title="技能5 个人品质"></a>技能5 个人品质</h4><p>归根结底，测试人员是有感情的人。如果你的团队想发挥出他们最好的一面，并因为你的影响力而进一步扩大自己——那就把它看作是你最大的胜利。</p>
<ul>
<li>直截了当是成为优秀领导者的标志性标志。您的团队将能够依靠您分享哪些信息，并使您更容易接近他们。</li>
<li>对你的职位没有自我问题。如果你犯了一个错误，请毫无问题地为此道歉！</li>
<li>始终与团队分享您的荣誉，因为毕竟，只有您的团队闪耀，您才会发光。</li>
<li>尝试使用”我们的”，”我们”，”我们”而不是我，你，他或她。灌输一种相互主人翁意识。</li>
<li>表现出对工作的热情。为了让团队对自己的工作充满热情并与之相关，责任在于测试线索，以辐射这种能量。</li>
<li>即使在工作中也能享受自己。虽然大多数情况下都有团队活动和有趣的活动计划，但没有规定乐趣必须限制在某一天。我们一起度过了一天中的大部分时间都，事情压力很大。一起喝茶，共进午餐，庆祝生日，计划一些即兴活动。这将在很大程度上有助于加强人际关系。</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/e907959e.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/e907959e.html" class="post-title-link" itemprop="url">测试领导职责及如何有效管理测试团队</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-03-01 21:31:53" itemprop="dateCreated datePublished" datetime="2022-03-01T21:31:53+08:00">2022-03-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h5 id="测试主管的职责"><a href="#测试主管的职责" class="headerlink" title="测试主管的职责"></a>测试主管的职责</h5><ol>
<li>他必须能够确定他的测试团队如何在组织内保持一致，以及他的团队将如何实现为项目和组织确定的路线图。</li>
<li>他需要根据文档的要求确定特定版本所需的测试范围。</li>
<li>在与测试团队讨论后，制定测试计划，并由管理&#x2F;开发团队进行审查和批准。</li>
<li>必须确定所需的指标并努力使其到位。这些指标可能是测试团队的固有目标。</li>
<li>必须通过计算给定版本所需的大小来确定所需的测试工作，并计划相同的所需工作量。</li>
<li>弄清楚需要哪些技能，并根据自己的兴趣相应地平衡测试资源与这些需求。并确定是否存在任何技能差距，并计划为已确定的测试资源进行培训和教育课程。</li>
<li>确定用于测试报告、测试管理、测试自动化等的工具，并教育团队如何使用这些工具。同样，如果需要，请向团队成员计划知识传授课程，以获取他们将使用的工具。</li>
<li>通过向他们灌输领导力来保留熟练的资源，并在需要时为初级资源提供指导，从而使他们能够成长。</li>
<li>为所有资源创造有趣和有利的环境，以确保它们具有最大的吞吐量。</li>
</ol>
<h5 id="有效管理测试团队"><a href="#有效管理测试团队" class="headerlink" title="有效管理测试团队"></a>有效管理测试团队</h5><ol>
<li>启动测试用例设计的测试规划活动，并鼓励团队召开评审会议并确保纳入评审注释。</li>
<li>在测试周期中，通过不断评估分配给每个资源的工作并根据需要重新平衡或重新分配它们来监视测试进度。</li>
<li>检查在实现时间表方面是否有任何延迟，并与测试人员进行讨论，以找出他们可能面临的问题，并努力解决这些问题。</li>
<li>在测试团队中召开会议，以确保每个人都知道其他团队成员在做什么。</li>
<li>向利益相关者和管理层展示及时的状态，并灌输对正在完成的工作的信心。</li>
<li>如果预见到任何延迟，请准备任何风险缓解计划。</li>
<li>弥合测试团队和管理层之间的任何差距和差异，以形成一个干净的双向接口通道。</li>
</ol>
<h5 id="测试管理"><a href="#测试管理" class="headerlink" title="测试管理"></a>测试管理</h5><p>虽然领导力可能意味着一个完整的领域，如权力、知识、主动性、直觉、影响决策的能力等，但很多时候，即使某些测试领导者天生就具备几乎所有这些品质，但由于他们试图带出这些品质的方式，他们仍然可能远离有效管理测试团队的目标。</p>
<p>通常在测试团队中，尽管领导力和管理是相辅相成的，但它们绝对不是一回事。</p>
<p>考试领导者可能拥有纸面上的所有领导技能，但这并不意味着他也可以管理团队。我们为测试过程本身设置了几个策略。然而，测试团队管理的艺术在为管理定义硬性规则方面通常是一个灰色地带。</p>
<p>关于为什么会这样，以及任何测试团队与其他团队有何不同，您有什么想法？</p>
<p>我认为，认识到测试团队使用理论上完美且经过验证的管理方法非常重要，它可能并不总是运作良好。</p>
<h5 id="有效管理测试团队需要考虑的重要事项"><a href="#有效管理测试团队需要考虑的重要事项" class="headerlink" title="有效管理测试团队需要考虑的重要事项"></a>有效管理测试团队需要考虑的重要事项</h5><p>为了有效地管理测试团队，需要考虑某些事实。</p>
<h6 id="1-了解测试人员"><a href="#1-了解测试人员" class="headerlink" title="1.了解测试人员"></a>1.了解测试人员</h6><p>测试人员的工作是发现软件中的缺陷或错误，以提高其质量。在团队中，可能会有测试人员绝对喜欢通过引入创新和创造性的测试风格来破解代码。毋庸置疑，这需要一个人具有技能，创造力和那种看待软件的心态，这种心态与其他人完全不同。</p>
<p>由于在日常生活中花费了大量的工作时间和不断增长的经验，测试资源几乎无法打破这种”测试”心态，它成为他们个人的一部分，在个人和专业上。他们几乎在从产品到流程，测试线索，经理等各个方面寻找缺陷。</p>
<p>花时间了解测试团队的这种心态是能够为测试主管派生合理的测试管理方法的第一步，也是最重要的一步。</p>
<h6 id="2-测试人员的工作环境"><a href="#2-测试人员的工作环境" class="headerlink" title="2.测试人员的工作环境"></a>2.测试人员的工作环境</h6><p>测试团队最常发现自己面临着很大的压力，因为对于使用给定的测试资源需要完成的大量测试有严格的截止日期。</p>
<p>有时，由于无数因素，在将代码交付给测试团队时可能会出现延迟，或者在获取所需环境时出现延迟，或者在修复&#x2F;验证缺陷时出现延迟。所有这一切，在时间表中没有扩展。</p>
<p>除此之外，可能需要大量的测试工作，因此测试不足或不完整可能会直接引起对产品质量的问题。</p>
<p>尽管测试团队可能会主动标记他们识别的某些风险，但很多时候，管理层可能不会非常积极地看待这一点，因为他们可能不完全了解所涉及的细节，或者他们可能会将其视为测试团队缺乏技能水平。</p>
<p>毫无疑问，测试团队会经历高度的挫败感以及按时交付的压力。衡量测试团队经常接触的环境，在其中工作对于测试主管&#x2F;经理进行有效管理可能是宝贵的投入。</p>
<h6 id="3-测试团队的角色"><a href="#3-测试团队的角色" class="headerlink" title="3.测试团队的角色"></a>3.测试团队的角色</h6><p>在测试领域工作了很多年后，意识到，再多的测试都不是”完整”的测试，发现”所有”缺陷是一种虚构的现象。</p>
<p>很多时候，无论进行大量的测试工作，都会在客户或生产环境中发现缺陷，并被称为从测试团队中”逃脱”。测试团队经常会受到此类逃生的打击，并被要求定量描述他们的测试覆盖范围，以破译此现场问题是否可能在测试周期中被捕获。</p>
<p>有时，这会让测试人员对如何根据自己的技能向他人描绘他们的角色感到非常失望，因此在更广泛的图景中，他们自己也是如此。</p>
<p>结论</p>
<p>了解测试团队中的所有这些现实将有助于<strong>设定要遵循的管理方法</strong>类型，这意味着很有可能摆脱标准和理论管理技术。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/4b7f751c.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/4b7f751c.html" class="post-title-link" itemprop="url">数据库测试指北</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-25 08:11:30" itemprop="dateCreated datePublished" datetime="2022-02-25T08:11:30+08:00">2022-02-25</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>数据库在软件应用程序中是无法避免的部分之一。</p>
<p>不管是web，桌面应用，移动端，B2B，B2C等，数据库在后端都是必需的。随着应用程序复杂程度的增加，对更强大更安全的数据库需求也随之增加。对于具有高交易频率的应用来说功能齐全的数据库的必要性是耦合的。</p>
<h4 id="为什么是数据库？"><a href="#为什么是数据库？" class="headerlink" title="为什么是数据库？"></a>为什么是数据库？</h4><p>下面会看到为什么要验证数据库的以下方面：</p>
<h5 id="①数据映射"><a href="#①数据映射" class="headerlink" title="①数据映射"></a>①数据映射</h5><p>在软件系统中，数据一般是在UI和后端数据库中来回传输，因为需要注意一下方面：</p>
<ul>
<li>检查UI、前端表单中的字段是否与数据表中的字段一直映射。通常映射信息在需求文档中定义；</li>
<li>当应用程序在前段执行某个操作时，都会在后端调用相应的CURD操作。作为测试人员必须检查是否正确的调用以及调用操作本身是否成功。</li>
</ul>
<h5 id="②ACID属性验证"><a href="#②ACID属性验证" class="headerlink" title="②ACID属性验证"></a>②ACID属性验证</h5><p>原子性、一致性、隔离性和持久性。数据库执行的每个事务都必须遵守这四个属性。</p>
<p><img src="/Echo/posts/4b7f751c/DB-Testing.jpg" alt="DB-Testing"></p>
<ul>
<li>原子性：事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</li>
<li>一致性：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须处于一致性状态。</li>
<li>隔离性：当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</li>
<li>持久性：事务一旦提交完成，任何外部因素（断电&#x2F;崩溃）都不能改变它。</li>
</ul>
<h5 id="③数据完整性"><a href="#③数据完整性" class="headerlink" title="③数据完整性"></a>③数据完整性</h5><p>对于任何CURD操作，共享数据更新的最新值&#x2F;状态都应显示在所有窗体和屏幕上。不应一个显示最新值一个显示比较旧的值。</p>
<p>C：创建–用户保存任何新的事务时，执行创建操作</p>
<p>R：检索–用户搜索或者查看任何已经保存的交易时，执行检索操作</p>
<p>U：更新–用户编辑或者修改现有记录时，执行更新操作</p>
<p>D：删除–用户从系统中删除任何记录时，执行删除操作</p>
<p>用户执行的任何数据库操作始终是以上四个操作之一。在设计数据库测试用例的方式包括检查数据在所有看起来的位置，以查看它是否始终相同。</p>
<h5 id="④业务规则一致性"><a href="#④业务规则一致性" class="headerlink" title="④业务规则一致性"></a>④业务规则一致性</h5><p>数据库中更复杂的组件意味着更复杂的组件，如关系约束、触发器、存储过程等。因此，测试人员必须提出适当的SQL查询才能验证这些复杂的对象。</p>
<h4 id="数据库测试清单"><a href="#数据库测试清单" class="headerlink" title="数据库测试清单"></a>数据库测试清单</h4><h5 id="1、事务"><a href="#1、事务" class="headerlink" title="1、事务"></a>1、事务</h5><p>测试事务时，确保满足ACID属性。</p>
<h5 id="2、数据库架构"><a href="#2、数据库架构" class="headerlink" title="2、数据库架构"></a>2、数据库架构</h5><ul>
<li>确定数据库运行所依据的要求。样品要求：<ul>
<li>在创建任何其他字段之前要创建的主键。</li>
<li>外键应完全索引，以便于检索和搜索。</li>
<li>字段名称以某些字符开头或结尾。</li>
<li>具有某些值可以或不能插入的约束的字段。</li>
</ul>
</li>
<li>根据相关性使用下列方法之一：<ul>
<li>SQL 查询 *DESC&lt;表名称&gt;*以验证架构。</li>
<li>用于验证各个字段的名称及其值的正则表达式</li>
<li>SchemaCrawler 等工具</li>
</ul>
</li>
</ul>
<h5 id="3、-触发器"><a href="#3、-触发器" class="headerlink" title="3、 触发器"></a>3、 触发器</h5><p>当某个事件发生在某个表上时，可以自动指示执行一段代码（触发器）。</p>
<p><strong>例如，</strong>一名新学生加入了一所学校。学生正在上2节课：数学和科学。学生将被添加到”学生表”中。一旦学生被添加到学生表中，触发器就可以将他添加到相应的主题表中。</p>
<p>测试的常用方法是首先独立执行触发器中嵌入的 SQL 查询并记录结果。接下来，将触发器作为一个整体执行。比较结果。</p>
<p>这些测试在黑盒和白盒测试阶段进行。</p>
<ul>
<li><strong>白盒测试</strong>：存根和驱动程序用于插入、更新或删除会导致触发器被调用的数据。基本思想是，即使在与前端（UI）集成之前，也只需单独测试数据库。</li>
<li><strong>黑盒测试</strong>:</li>
</ul>
<p><strong>a）</strong> 由于 UI 和 DB，集成现在可用;我们可以以调用触发器的方式从前端插入&#x2F;删除&#x2F;更新数据。之后，Select 语句可用于检索数据库数据，以查看触发器是否成功执行了预期的操作。</p>
<p><strong>b）</strong> 测试这一点的第二种方法是直接加载将调用触发器的数据，并查看它是否按预期工作。</p>
<h5 id="4、-存储过程"><a href="#4、-存储过程" class="headerlink" title="4、 存储过程"></a>4、 存储过程</h5><p>存储过程或多或少类似于用户定义的函数。这些语句可以通过调用过程&#x2F;执行过程语句调用，并且输出通常采用结果集的形式。</p>
<p>它们存储在 RDBMS 中，可用于应用程序。</p>
<p><strong>这些也在以下时间进行测试：</strong></p>
<ul>
<li><strong>白盒测试：</strong>存根用于调用存储过程，然后根据预期值验证结果。</li>
<li><strong>黑盒测试：</strong>从应用程序的前端 （UI） 执行操作，并检查存储过程的执行及其结果。</li>
</ul>
<h5 id="5、字段约束"><a href="#5、字段约束" class="headerlink" title="5、字段约束"></a>5、字段约束</h5><p><strong>默认值、唯一值和外键：</strong></p>
<ul>
<li>执行执行数据库对象条件的前端操作</li>
<li>使用 SQL 查询验证结果。</li>
</ul>
<p>检查某个字段的默认值非常简单。它是业务规则验证的一部分。您可以手动执行此操作，也可以使用QTP等工具。您可以手动执行一项操作，该操作将从前端添加字段默认值以外的值，并查看它是否会导致错误。</p>
<h4 id="数据库测试活动"><a href="#数据库测试活动" class="headerlink" title="数据库测试活动"></a>数据库测试活动</h4><h5 id="1）-确保数据映射："><a href="#1）-确保数据映射：" class="headerlink" title="#1） 确保数据映射："></a><strong>#1） 确保数据映射：</strong></h5><p>数据映射是数据库中的关键方面之一，每个软件测试人员都应该对其进行严格的测试。</p>
<p>确保AUT与其数据库的不同表单或屏幕之间的映射不仅准确，而且符合设计文档（SRS &#x2F; BRS）或代码。基本上，您需要验证每个前端字段与其相应的后端数据库字段之间的映射。</p>
<p>对于所有 CRUD 操作，请验证当用户从应用程序的 GUI 中单击”保存”、”更新”、”搜索”或”删除”时，是否更新了相应的表和记录。</p>
<p><strong>您需要验证的内容：</strong></p>
<ul>
<li>表映射、列映射和数据类型映射。</li>
<li>查找数据映射。</li>
<li>在 UI 上为每个用户操作调用正确的 CRUD 操作。</li>
<li>CRUD 操作成功。</li>
</ul>
<h5 id="2）确保事务的ACID属性："><a href="#2）确保事务的ACID属性：" class="headerlink" title="#2）确保事务的ACID属性："></a><strong>#2）确保事务的ACID属性：</strong></h5><p>DB Transactions的ACID属性<strong>是指”原子</strong>性”，”Consistency”，”<strong>Isolation</strong>“和”<strong>Durability</strong>“。在数据库测试活动期间，必须对这四个属性进行适当的测试。您需要验证每个事务是否都满足数据库的 ACID 属性。</p>
<p><img src="/Echo/posts/4b7f751c/ACID-Properties.jpg" alt="ACID-Properties"></p>
<p><strong>让我们通过下面的SQL代码举一个简单的例子：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE acidtest (A INTEGER, B INTEGER, CHECK (A + B = 100));</span><br></pre></td></tr></table></figure>

<p>ACID测试表将有两列 - A和B。存在一个完整性约束，即 A 和 B 中的值之和应始终为 100。</p>
<p><strong>原子性测试</strong>将确保在此表上执行的任何事务都是全部或无，即如果事务的任何步骤失败，则不会更新任何记录。</p>
<p><strong>一致性测试</strong>将确保每当更新列 A 或 B 中的值时，总和始终保持为 100。如果总和不是 100，则不允许在 A 或 B 中插入&#x2F;删除&#x2F;更新。</p>
<p><strong>隔离测试</strong>将确保如果两个事务同时发生并尝试修改ACID测试表的数据，则这些牵引力是孤立执行的。</p>
<p><strong>耐久性测试</strong>将确保一旦提交了此表上的事务，即使发生断电、崩溃或错误，它仍将保持这种状态。</p>
<p>如果您的应用程序正在使用分布式数据库，则需要进行更严格、彻底和敏锐的测试。</p>
<p><strong>#3） 确保数据完整性</strong></p>
<p>考虑应用程序的不同模块（即屏幕或表单）以不同的方式使用相同的数据，并对数据执行所有CRUD操作。</p>
<p>在这种情况下，请确保在各处都反映最新的数据状态。系统必须在所有表单和屏幕上显示更新和最新的值或此类共享数据的状态。这称为数据完整性。</p>
<p><img src="/Echo/posts/4b7f751c/di.jpg" alt="di"></p>
<p><strong>验证数据库数据完整性的测试用例：</strong></p>
<ul>
<li>检查是否所有触发器都已就位以更新引用表记录。</li>
<li>检查每个表的主要列中是否存在任何不正确&#x2F;无效的数据。</li>
<li>尝试在表中插入错误的数据，并观察是否发生任何故障。</li>
<li>检查在插入父级之前尝试插入子项会发生什么情况（尝试使用主键和外键）。</li>
<li>测试在删除仍由任何其他表中的数据引用的记录时是否发生任何故障。</li>
<li>检查复制的服务器和数据库是否同步。</li>
</ul>
<p><strong>#4）确保已实现的业务规则的准确性：</strong></p>
<p>如今，数据库不仅仅用于存储记录。事实上，数据库已经发展成为非常强大的工具，为开发人员在数据库级别实现业务逻辑提供了充分的支持。</p>
<p>强大功能的一些简单示例包括”参照完整性”、关系约束、触发器和存储过程。</p>
<p>因此，使用 DB 提供的这些功能和许多其他功能，开发人员可以在 DB 级别实现业务逻辑。测试人员必须确保实现的业务逻辑正确且工作准确。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/48610.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/48610.html" class="post-title-link" itemprop="url">什么是Kubernetes</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-19 01:46:10" itemprop="dateCreated datePublished" datetime="2022-02-19T01:46:10+08:00">2022-02-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>近期开始学习Kubernetes，后续会将学习中整理的一些知识通过QA的方式记录在个人博客中。后续文章中Kubernetes简称为K8S。</p>
<h5 id="Q1、K8S是什么？"><a href="#Q1、K8S是什么？" class="headerlink" title="Q1、K8S是什么？"></a>Q1、K8S是什么？</h5><p>K8S是基于容器技术的分布式架构领先方案。它是谷歌十几年以来大规模应用容器化技术的经验积累和升华的重要成果。K8S是站Brog系统的肩膀上，汲取了brog过去的经验与教训，所以K8S现世时，让一众架构师为之疯狂。</p>
<h5 id="Q2、系统设计遵循了K8S的设计思想会带来什么？"><a href="#Q2、系统设计遵循了K8S的设计思想会带来什么？" class="headerlink" title="Q2、系统设计遵循了K8S的设计思想会带来什么？"></a>Q2、系统设计遵循了K8S的设计思想会带来什么？</h5><p>传统系统架构中和业务没有多大关系的底层代码或功能模块，都将消失在眼前，也不需要花费时间在负载均衡器的选型和部署实施问题，不需要考虑服务治理框架，不必在为服务监控和故障处理模块的开发而头疼。业内认为使用K8S可以减少30%，可以将精力更集中于业务本身，同时K8S提供了强大的自动化机制，后期的运维难度和运维成本大大降低。</p>
<h5 id="Q3、K8S有语言限制吗？"><a href="#Q3、K8S有语言限制吗？" class="headerlink" title="Q3、K8S有语言限制吗？"></a>Q3、K8S有语言限制吗？</h5><p>K8S没有语言限制，是一个开放的平台。不局限于任何一种语言，没有限定编程接口。不管使用什么语言编写的服务都可以映射在K8S的service里面，通过标准的TCP协议进行交互。K8S平台对现有的编程语言、编程框架、中间件没有任何侵入性。</p>
<h5 id="Q4、K8S有什么功能？"><a href="#Q4、K8S有什么功能？" class="headerlink" title="Q4、K8S有什么功能？"></a>Q4、K8S有什么功能？</h5><p>K8S有完备的集群管理能力，有多层次的安全防护和准入机制、多租用应用支撑、透明的服务注册、服务发现机制、自能负载均衡器、故障发现和自我修复能力、服务滚动升级、在线扩容、资源自动调度、多粒度资源配额管理能力。</p>
<h5 id="Q5-K8S会带来什么好处？"><a href="#Q5-K8S会带来什么好处？" class="headerlink" title="Q5 K8S会带来什么好处？"></a>Q5 K8S会带来什么好处？</h5><p>① 复杂系统可以模块化开发。以前很多技术大牛一起分工协作完成的分布式系统，现在仅需要一个架构师负责服务中组件的设计，几个业务人员负责业务代码开发，一个运维负责部署服务到K8S上，其他的K8S会帮我们完成。</p>
<p>②我们可以全面的拥抱微服务架构。微服务架构的核心是将一个巨大的单体应用分解为很多小的互相连接的微服务，一个微服务可能由多个实例副本支撑，副本的数量可以随着系统的负荷变化进行调整。微服务架构使得每个服务都可以独立开发、升级和扩展，因此系统具备很高的稳定性和快速迭代能力，开发者也可以自由选择开发技术。</p>
<p>③可以随时将系统整体的搬到云上。K8S的架构方案中完全屏蔽了底层网络的细节，基于Service的虚拟IP地址（Cluster IP）的设计思路让架构与底层的硬件拓扑无关，无须改变运行期的配置文件，就能将系统从现有的物理机环境无缝迁移到云上。</p>
<p>④K8S内在弹性扩容机制轻松应对突发流量。12306会在节假日租用阿里云的服务进行扩容，来满足用户需求。</p>
<p>⑤K8S超强的横向扩容能力让竞争力大大提升。对于公司来说，用户规模等同于有价资产，基于此，横向扩容能力是衡量企业尤其是互联网企业的竞争力的关键指标。K8S提供的工具，不用修改代码，就能将一个K8S集群从只包含几个Node的小集群平滑扩展到拥有上百个Node的大集群，甚至可以在线完成集群扩容。只要微服务架构设计得合理，能够在多个云环境中进行弹性伸缩，系统就能够承受大量用户并发访问带来的巨大压力。</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>K8S是一个全新的基于容器化的分布式架构解决方案，并且是一个一站式的完备的分布式系统开发和支撑平台。能让公司更加专注于业务，而减轻架构和运维的要求，缩短产品上线周期。</p>
<p>后续会介绍K8S的相关概念和术语。和大家一起来学习K8S。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/25505.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/25505.html" class="post-title-link" itemprop="url">接口测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-09 10:43:40" itemprop="dateCreated datePublished" datetime="2022-02-09T10:43:40+08:00">2022-02-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="什么是接口？"><a href="#什么是接口？" class="headerlink" title="什么是接口？"></a>什么是接口？</h4><p>当开发应用程序或者网站时，会有不同组件进行集成，集成并促进这些组件之间通信的连接成为接口。简而言之，接口是由一组命令，消息等组成的软件。这些不同组件之间的通信会影响整体性能，因此需要进行测试和验证。</p>
<h4 id="什么是接口测试？"><a href="#什么是接口测试？" class="headerlink" title="什么是接口测试？"></a>什么是接口测试？</h4><p>为验证接口功能而进行的测试称为接口测试</p>
<p><img src="/Echo/posts/25505/Interface-Testing-Flow.jpg" alt="Interface-Testing-Flow"></p>
<p>接口测试中常见的组件：</p>
<ul>
<li>web服务和应用程序之间的接口</li>
<li>数据库服务和应用程序之间的接口</li>
</ul>
<h4 id="我们何时以及如何测试接口？"><a href="#我们何时以及如何测试接口？" class="headerlink" title="我们何时以及如何测试接口？"></a>我们何时以及如何测试接口？</h4><p><img src="/Echo/nterface-Testing_component.jpg" alt="Interface-Testing_component"></p>
<p>接口测试的3个阶段</p>
<ol>
<li>配置</li>
</ol>
<p>开发配置完接口后，根据需求验证配置；</p>
<ol start="2">
<li>验证</li>
</ol>
<p>开发完成后，对接口进行验证，这一部分也可以作为单元测试来进行。</p>
<p>  3.维护</p>
<p>整个软件准备就绪，部署完成并正常工作后，需要监控性能，由于系统做出更改或者性能调整可能会引入一些新问题。</p>
<p>接口测试主要是为了：</p>
<ul>
<li>服务器执行是否正确</li>
<li>错误信息处理并正常展示</li>
<li>与服务器连接重置时检查结果</li>
<li>组建内部通信的安全性检查</li>
<li>网络故障对组件之间通信的影响</li>
</ul>
<h4 id="接口测试的类型"><a href="#接口测试的类型" class="headerlink" title="接口测试的类型"></a>接口测试的类型</h4><p>接口测试基本是在系统架构的消息传递层完成的，主要涉及使用json，XML，rest API，SOAP web。</p>
<p>接口测试一般涉及以下做法：</p>
<p>单元测试：测试每个单独操作的功能（函数）</p>
<p>功能测试：测试相关接口要实现的功能</p>
<p>负载测试：验证负载下接口的性能</p>
<p>安全测试：测试安全机制，包含渗透测试，访问控制，加密等</p>
<p>运行时错误检测：监视程序运行时资源的争用、泄漏等问题</p>
<p>工作流测试：接口引擎是否按照预期处理工作流</p>
<p>单个系统测试：验证每个系统可以独立运行</p>
<h4 id="接口测试中注意清单"><a href="#接口测试中注意清单" class="headerlink" title="接口测试中注意清单"></a>接口测试中注意清单</h4><ul>
<li>测试中应包含4XX和5XX错误，有助于验证客户端和服务端错误处理，显示适当消息而不是代码错误。</li>
<li>使用HTTP身份验证验证用户</li>
<li>验证API中常用的使用方法，如get，put，delete，post等</li>
<li>验证从json到xml格式的转换，反之亦然</li>
<li>验证接口上的批量操作是否在获取正确的预期结果</li>
<li>验证API时区与地理时区是否匹配</li>
<li>验证未经授权的访问是否报错</li>
<li>验证连接中断的处理</li>
<li>验证从程序中删除部分组件，接口不再与之发生交互</li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/42873.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/42873.html" class="post-title-link" itemprop="url">手工测试如何过渡到自动化测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-06 21:44:55" itemprop="dateCreated datePublished" datetime="2022-02-06T21:44:55+08:00">2022-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p><img src="/Echo/posts/42873/Transition-from-Manual-to-Automated-Testing-Banner.png" alt="Transition-from-Manual-to-Automated-Testing-Banner"></p>
<h4 id="手工测试与自动化测试的区别"><a href="#手工测试与自动化测试的区别" class="headerlink" title="手工测试与自动化测试的区别"></a>手工测试与自动化测试的区别</h4><p>手工测试：顾名思义就是测试人员自己手动执行所有测试步骤，以便在应用程序发布之前查找错误。</p>
<p>自动化测试：测试人员编写自动化脚本以自动化工具自动执行测试步骤。测试人员将测试脚本存储起来作为资产来进行重用，从而为重复执行节省大量时间和精力。</p>
<h4 id="为什么要从手工测试转到自动化测试"><a href="#为什么要从手工测试转到自动化测试" class="headerlink" title="为什么要从手工测试转到自动化测试"></a>为什么要从手工测试转到自动化测试</h4><p>自动化测试可以克服许多手工测试中遇到的挑战，在敏捷项目中尤为重要。</p>
<p>1、测试可重用性</p>
<p>自动化测试用例和测试套件可以在不同的测试周期和测试环境中多次重用。因此，每次应用程序更改时，您都可以运行自动回归测试套件来检查回归错误，从而避免重复手动执行回归测试。这是自动化降低操作故障风险的最重要优势之一。</p>
<p>2、更高的测试覆盖率</p>
<p>由于测试是自动执行的，因此有更多时间专注于新的测试方案，并编写更自动化的测试用例来验证和确认受测应用程序 （AUT）。可以自由地进行更多的探索性测试，以确保产品质量。</p>
<p>自动测试也可以在不同的平台和设备上同时或并行执行。执行的测试越多，意味着可能会发现更多的回归错误，并确认更多的业务需求。</p>
<p>3、更早的错误检测和反馈</p>
<p>在生产环境中发现的 Bug 在时间、金钱和精力等方面修复成本更高。这就是为什么团队正在向左移动，更早地发现错误以最大限度地降低成本。</p>
<p>如果自动化测试做得好，可以在开发阶段开始后立即开始。开发人员可以在将代码提交到版本控制系统之前在其本地计算机上执行单元测试。</p>
<p>单元测试也可以集成到 CI 管道中。提交代码后，将触发管道以运行自动化单元测试，然后运行集成或系统测试。通过这种方式，开发人员可以更快地接收反馈，检测和修复错误，防止bug潜入后期阶段。</p>
<p>4、超越手工测试</p>
<p>测试自动化可以完成手动测试可能难以实现的工作，特别是对于需要大量精力和资源（如性能测试）的特定测试。它可以模拟来自不同平台和设备对AUT服务器端的数千个同时请求，这几乎不可能手动完成。</p>
<p>在并行执行方面，自动化工具的工作速度比人类快，精度更高。机器不会像人类那样感到无聊或疲惫，可以避免类似人类的错误。因此，测试结果是可靠且快速接收的。（PS：要记住的一件事是，长远来看，自动化测试是有效的，但是自动化测试初始成本较高，需要时间和设备将所有内容落实到位，才会带来可观的效果并降低成本效益比）。</p>
<h4 id="什么情况不值得开展自动化测试？"><a href="#什么情况不值得开展自动化测试？" class="headerlink" title="什么情况不值得开展自动化测试？"></a>什么情况不值得开展自动化测试？</h4><p>以下四种情况，要开展自动化测试前请慎重、慎重、慎重考虑</p>
<ul>
<li>短期的项目</li>
<li>开发在4-6月内完成的简单应用程序</li>
<li>不经常运行测试</li>
<li>测试许多手工执行起来更容易的复杂方案</li>
</ul>
<h4 id="从手工测试过渡到自动化测试"><a href="#从手工测试过渡到自动化测试" class="headerlink" title="从手工测试过渡到自动化测试"></a>从手工测试过渡到自动化测试</h4><h5 id="Step1、设计自动化测试策略"><a href="#Step1、设计自动化测试策略" class="headerlink" title="Step1、设计自动化测试策略"></a>Step1、设计自动化测试策略</h5><p>许多团队通常都很挣扎，因为他们没有面向目标的测试自动化策略。它使所有团队成员都在同一页面上。它告知并传达预先定义的目标和计划，每个人都可以从中了解他们所做的事情是对还是错，并调整下一步行动。</p>
<p>如果没有清晰的愿景战略，团队很容易改变方向，选择错误的解决方案，并且无法以有助于实现业务价值的方式使用自动化测试。</p>
<p>自动化测试就像构建并拥有自己的软件来测试其他应用程序一样。它应该以与软件开发相同的方式以清晰的愿景和计划进行管理。</p>
<h5 id="Setp2、丰富自动化测试基础"><a href="#Setp2、丰富自动化测试基础" class="headerlink" title="Setp2、丰富自动化测试基础"></a>Setp2、丰富自动化测试基础</h5><p>了解测试自动化的所有基础知识至关重要，从敏捷和 DevOps 方法、框架构建、自动化金字塔、架构、自动化方法到报告和指标。没有良好的基础，团队几乎无法执行其战略。</p>
<p>此外，还应该检查特定的自动化解决方案或测试工具，它们需要哪些技能，它们解决了什么问题，以及它们在实践中是如何做到的。并保持学习过程不间断。</p>
<p>许多团队只是在一段时间后停止更新其知识库。随着新技术、新趋势和新解决方案的出现，行业发展迅速，停止学习和培训只能意味着落后于竞争对手。</p>
<h5 id="Step3、-编程技能"><a href="#Step3、-编程技能" class="headerlink" title="Step3、 编程技能"></a>Step3、 编程技能</h5><p>许多测试自动化解决方案需要编程技能来构建框架和编写自动化测试脚本。为了克服这些障碍，许多团队的目标是使用配备低代码功能的现成测试工具。</p>
<p>但是，没有编程技能，测试人员只能使用内置的关键字、录制和播放功能，或者具有直观 UI 的手动模式来创建自动测试。事情会永远这么简单吗？</p>
<p>从长远来看，要编写更复杂的测试用例、修改脚本、构建自定义关键字、维护测试或调试失败的测试，团队中至少应该有一个熟悉编码和编程的自动化测试人员或一个开发人员来支持。</p>
<p>因此，如果团队想要从手动测试切换到自动测试，请考虑雇用具有编程背景的测试人员，或者让团队成员学习和提高他们的编码技能。</p>
<h5 id="Step4、-选择适合自己的测试工具"><a href="#Step4、-选择适合自己的测试工具" class="headerlink" title="Step4、 选择适合自己的测试工具"></a>Step4、 选择适合自己的测试工具</h5><p>工具选择可能非常棘手，因为市场上有数千种可用选项。仅根据其他人的成功来选择他们的工具。但是，一个工具对其他工具有效并不一定意味着它对你有同样的作用。</p>
<p>考虑团队的特定需求和资源。也就是说，这里有一些问题需要评估和选择最合适的解决方案：</p>
<ul>
<li><strong>想解决什么问题？</strong>确定要应用自动测试的 AUT（Web、桌面或移动应用程序）以及所需的功能（用于测试创建、执行、报告等）。</li>
<li><strong>谁使用该工具？</strong> 如果他们是手动测试人员，那么低代码解决方案将更合适。</li>
<li><strong>能否融入团队的现有流程和工具链？</strong>寻找具有本机集成的自动化工具，以减少变通方法的时间。</li>
<li><strong>是否面向未来？</strong>为避免从一个工具切换到另一个工具，请考虑团队的可伸缩性，并选择可以满足未来需求的工具。</li>
<li><strong>预算是多少？</strong> 开源是免费的，但需要时间来设置和开发测试自动化工具，而商业工具可以快速启动且易于使用。</li>
<li><strong>从哪里可以获得支持？</strong>良好的客户支持或活跃的社区可以在处理技术问题时真正帮助您并节省时间。</li>
</ul>
<p><strong>提示</strong>：从手动起点开始，最好选择一个现成的工具，它具有低代码和脚本选项，如<a target="_blank" rel="noopener" href="https://www.softwaretestinghelp.com/katalon-studio-tutorial/">Katalon Studio</a>。它将为您节省大量时间来构建框架和功能，这是启动测试自动化时压力最大的部分。</p>
<p>借助”录制”和”回放”等低代码功能，手动测试人员可以快速开始自动执行测试用例并捕获测试对象。之后，当拥有更多的编码经验时，他们可以继续编写测试脚本，构建更多的自定义关键字，并利用更高级的功能。</p>
<p>选择工具后，请记住进行概念验证。在工具上运行快速冲刺，让所有团队成员参与进来。然后，在冲刺 （sprint） 结束时，收集所有反馈并评估该工具是否能够满足团队的所有标准要求。</p>
<h5 id="Setp5、-小demo运行，自信扩展"><a href="#Setp5、-小demo运行，自信扩展" class="headerlink" title="Setp5、 小demo运行，自信扩展"></a>Setp5、 小demo运行，自信扩展</h5><p>从小项目的特定小目标开始，例如在一段时间内达到某个自动化测试用例。保持错误小，从中吸取教训，并逐步扩大团队测试自动化的规模。不要因为过于雄心勃勃致使事情复杂化而延迟过渡。</p>
<h4 id="The-End"><a href="#The-End" class="headerlink" title="The End"></a>The End</h4><p>从手动自动化转向测试自动化可能是一个困难的长期过程。没有仔细的规划，缺乏所需的技能组合以及不合适的解决方案是导致团队挣扎的一些最常见的根本原因。欢迎在下边的讨论区我们一起交流。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/59445.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/59445.html" class="post-title-link" itemprop="url">2022年软件测试趋势</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-06 16:10:34" itemprop="dateCreated datePublished" datetime="2022-02-06T16:10:34+08:00">2022-02-06</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>技术呈指数级和前所未有的变化影响了组织开发、验证、交付和操作软件的方式。</p>
<p>因此，这些组织必须通过寻找解决方案来不断创新和改造自己，以优化实践和工具，以快速开发和交付高质量的软件。</p>
<p>软件测试约占项目总工作量的30%，是更改和改进的重要焦点。测试实践和工具需要不断发展，以应对在系统、环境和数据日益复杂的情况下实现**”快速测试”**的挑战。</p>
<p>在下面介绍了软件测试的主要趋势，其中许多趋势在过去几年中已经出现。我们观察到，敏捷和DevOps、测试自动化、用于测试的人工智能和API测试自动化是2022年和未来几年最引人注目的趋势。</p>
<h4 id="1、敏捷和Devops"><a href="#1、敏捷和Devops" class="headerlink" title="1、敏捷和Devops"></a>1、敏捷和Devops</h4><p>敏捷已经视为对快速变化的需求的回应，并将DevOps视为对速度需求的响应。</p>
<p>DevOps 涉及实践、规则、流程和工具，有助于集成开发和运营活动，从而缩短从开发到运营的时间。DevOps已成为组织广泛接受的解决方案，这些组织正在寻找缩短从开发到交付和运营的软件生命周期的方法。</p>
<p>敏捷和DevOps的采用有助于团队更快地开发和交付高质量的软件，这反过来又被称为”速度的测试”。这种采用在过去五年中引起了很大的兴趣，并且在未来几年也将继续加强。</p>
<h4 id="2、测试自动化"><a href="#2、测试自动化" class="headerlink" title="2、测试自动化"></a>2、测试自动化</h4><p>为了有效地实施 DevOps 实践，软件团队不能忽视测试自动化，因为它是 DevOps 流程的基本要素。</p>
<p>需要找到机会，用自动化测试取代手动测试。由于测试自动化被认为是DevOps的重要瓶颈，因此至少大多数回归测试都应该是自动化的。</p>
<p>鉴于DevOps的普及以及测试自动化未得到充分利用的事实，只有不到20%的测试是自动化的，因此在组织中增加测试自动化的采用空间很大。应该出现更先进的方法和工具，以便在项目中更好地利用测试自动化。</p>
<h4 id="3、-API和服务自动化测试"><a href="#3、-API和服务自动化测试" class="headerlink" title="3、 API和服务自动化测试"></a>3、 API和服务自动化测试</h4><p>将客户端和服务器分离是设计 Web 和移动应用程序的当前趋势。</p>
<p>API 和服务在多个应用程序或组件中重用。反过来，这些更改要求团队独立于使用它们的应用程序测试 API 和服务。</p>
<p>当跨客户端应用程序和组件使用 API 和服务时，测试它们比测试客户端更有效和高效。趋势是对API和服务测试自动化的需求继续增加，可能超过最终用户在用户界面上使用的功能。</p>
<p>为 API 自动化测试提供正确的流程、工具和解决方案比以往任何时候都更加重要。</p>
<h4 id="4、用于测试AI和ML"><a href="#4、用于测试AI和ML" class="headerlink" title="4、用于测试AI和ML"></a>4、用于测试AI和ML</h4><p>尽管应用人工智能和机器学习（AI &#x2F; ML）方法来解决软件测试中的挑战在软件研究社区中并不新鲜，但AI &#x2F; ML的最新进展以及大量可用的数据为在测试中应用AI &#x2F; ML提供了新的机会。</p>
<p>然而，AI&#x2F;ML在测试中的应用仍处于早期阶段。扔在寻找在AI &#x2F; ML中优化其测试实践的方法。</p>
<p>AI&#x2F;ML 算法旨在生成更好的测试用例、测试脚本、测试数据和报告。预测模型将有助于决定在何处、做什么以及何时进行测试。智能分析和可视化支持团队检测故障，了解测试覆盖范围，高风险区域等。</p>
<p>希望在未来几年看到AI &#x2F; ML在解决质量预测，测试用例优先级，故障分类和分配等问题中的更多应用。</p>
<h4 id="5、移动测试自动化"><a href="#5、移动测试自动化" class="headerlink" title="5、移动测试自动化"></a>5、移动测试自动化</h4><p>随着移动设备的功能越来越强大，移动应用程序开发的趋势继续增长。</p>
<p>要完全支持 DevOps，移动测试自动化必须是 DevOps 工具链的一部分。然而，目前移动测试自动化的利用率非常低，部分原因是缺乏方法和工具。</p>
<p>移动应用的自动化测试趋势持续增加。这种趋势是由缩短上市时间的需求以及用于移动测试自动化的更高级方法和工具所驱动的。</p>
<h4 id="6、测试环境和测试数据"><a href="#6、测试环境和测试数据" class="headerlink" title="6、测试环境和测试数据"></a>6、测试环境和测试数据</h4><p>物联网（IoT）的快速增长）意味着更多的软件系统在众多不同的环境中运行。这给测试团队带来了确保正确级别的测试覆盖率的挑战。事实上，在敏捷项目中申请测试时，缺乏测试环境和数据是最大的挑战。</p>
<p>将看到在提供和使用基于云的容器化测试环境方面的增长。AI&#x2F;ML在生成测试数据方面的应用和数据项目的增长，是解决测试数据不足的一些解决方案。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://hugfeature.github.io/Echo/posts/17757.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/Echo/images/avatar.gif">
      <meta itemprop="name" content="丑牛">
      <meta itemprop="description" content="曾经梦想仗剑走天涯!<br>因为遇见她，所以回了家！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="测试的名义">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/Echo/posts/17757.html" class="post-title-link" itemprop="url">Cookie测试</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-02-05 14:12:59" itemprop="dateCreated datePublished" datetime="2022-02-05T14:12:59+08:00">2022-02-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/Echo/categories/%E6%B5%8B%E8%AF%95/" itemprop="url" rel="index"><span itemprop="name">测试</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h4 id="什么是Cookie？"><a href="#什么是Cookie？" class="headerlink" title="什么是Cookie？"></a>什么是Cookie？</h4><p> Cookie 是由网络服务器存储在用户硬盘上的文本文件中的一小段信息。Web 浏览器稍后将使用此信息从该计算机检索信息。</p>
<p>通常，Cookie包含用于在不同网页之间进行通信的个性化用户数据或信息。</p>
<h4 id="为什么使用cookie？"><a href="#为什么使用cookie？" class="headerlink" title="为什么使用cookie？"></a>为什么使用cookie？</h4><p>Cookies只不过是记录用户的身份，用于跟踪用户在整个网站页面中的导航位置。但是Web 浏览器和 Web 服务器之间的通信是无状态的。</p>
<p><strong>例：</strong></p>
<p>如果正在访问域”<a target="_blank" rel="noopener" href="http://www.example.com/1.html&quot;%EF%BC%8C%E5%88%99Web%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B0%86%E4%BB%85%E5%90%91">http://www.example.com/1.html&quot;，则Web浏览器将仅向</a> example.com Web服务器查询第1.html页。</p>
<p>下次，如果将页面键入为”<a target="_blank" rel="noopener" href="http://www.example.com/2.html&quot;%EF%BC%8C%E5%88%99%E6%96%B0%E8%AF%B7%E6%B1%82%E5%B0%86%E5%8F%91%E9%80%81%E5%88%B0">http://www.example.com/2.html&quot;，则新请求将发送到</a> example.com Web服务器以发送2.html页面，并且Web服务器不知道有关上一页1.html的任何信息。</p>
<p>如果想要此用户与 Web 服务器通信的先前历史记录，该怎么办？需要在某个位置维护 Web 浏览器和 Web 服务器之间的用户状态和交互。这就是饼干进入画面的地方。Cookie 用于维护用户与网络服务器的交互。</p>
<h4 id="Cookie是如何工作的？"><a href="#Cookie是如何工作的？" class="headerlink" title="Cookie是如何工作的？"></a>Cookie是如何工作的？</h4><p>Cookie用于维护在HYYP协议上 Web 上交换信息的文件。</p>
<p>有两种类型的 HTTP 协议。无状态 HTTP 和有状态 HTTP 协议。无状态 HTTP 协议不保留以前访问过的网页历史记录的任何记录。虽然有状态 HTTP 协议确实保留了以前的 Web 浏览器和 Web 服务器交互的一些历史记录，但 Cookie 使用此协议来维护用户交互。</p>
<p>每当用户访问使用cookie的网站或页面时，该HTML页面中的小代码（通常，调用某些语言脚本来编写cookie，如JAVAScript，PHP，Perl中的cookie）会在用户的计算机上写入一个文本文件，称为cookie。</p>
<p>下面一段示例代码如何设置写一个cookie，可以放在任何HTML页面上：</p>
<p><strong>Set-Cookie: NAME&#x3D;VALUE; expires&#x3D;DATE; path&#x3D;PATH; domain&#x3D;DOMAIN_NAME;</strong></p>
<p>当用户稍后访问同一页面或域时，将从磁盘读取此 Cookie，并用于标识该域上同一用户的第二次访问。过期时间是在写入 Cookie 时设置的。此时间由要使用 Cookie 的应用程序决定。</p>
<p>通常，在用户计算机上写入两种类型的Cookie</p>
<p><strong>会话 Cookie：</strong>此 Cookie 处于活动状态，直到调用该 Cookie 的浏览器打开。当我们关闭浏览器时，此会话cookie将被删除。有时，可以将 20 分钟的会话设置为使 Cookie 过期。</p>
<p><strong>持久性 Cookie：</strong>这些是永久写入用户计算机上并持续数月或数年的 Cookie。</p>
<h4 id="Cookie存储在哪里？"><a href="#Cookie存储在哪里？" class="headerlink" title="Cookie存储在哪里？"></a>Cookie存储在哪里？</h4><p>当任何网页应用程序写入 Cookie 时，它会保存在用户硬盘驱动器上的文本文件中。存储 Cookie 的路径取决于浏览器。不同的浏览器将 Cookie 存储在不同的路径中。</p>
<p> <strong>Cookie 存储位置示例：</strong></p>
<p><strong>Edge：</strong> <em>“C：\Users\username\AppData\Roaming\Microsoft\Windows\Cookies”。</em></p>
<p>**Windows 7：”**<em>C：\Users\username\AppData\Roaming\Microsoft\Windows\Cookies\Low”。</em></p>
<p>**Windows 8 和 Windows 10：”**<em>C：\Users\username\AppData\Local\Microsoft\Windows\INetCookies”。</em></p>
<p>在这里，”默认用户”可以替换为您登录的当前用户，如”管理员”，或用户名，如”admin”等。通过浏览浏览器选项可以轻松找到 Cookie 路径。</p>
<p>在Mozilla Firefox浏览器中，您甚至可以在浏览器选项本身中看到cookie。打开 Mozilla 浏览器，按”打开菜单”按钮？”网络开发人员”？”存储检查器”或按组合”Shift + F9”。</p>
<p>在谷歌浏览器中，您可以通过在地址栏中输入”chrome:&#x2F;&#x2F;settings&#x2F;content&#x2F;cookies”来查找cookie。也可以使用浏览器控制台访问 Cookie：按 F12 – &gt; 应用程序 – &gt;存储 – &gt; Cookie。</p>
<h4 id="Cookie是如何存储的？"><a href="#Cookie是如何存储的？" class="headerlink" title="Cookie是如何存储的？"></a>Cookie是如何存储的？</h4><p>以 <a target="_blank" rel="noopener" href="http://www.rediff.com/">rediff.com</a> 在 Mozilla Firefox 浏览器上编写的 Cookie 为例。在 Mozilla Firefox 浏览器上，当您打开 rediff.com 页面或登录您的 Rediffmail 帐户时，您的硬盘上会写入一个 Cookie。</p>
<p>要查看此 Cookie，只需单击上述路径中提到的”显示 Cookie”按钮即可。单击此 Cookie 列表下的 Rediff.com 站点。</p>
<p><em><strong>可以看到 Rediff 域中写入的不同 Cookie 具有不同的名称。</strong></em></p>
<p><strong>Site:</strong> Rediff.com Cookie name: RMID<br><strong>Name:</strong> RMID (Name of the cookie)<br><strong>Content:</strong> 1d11c8ec44bf49e0… (Encrypted content)<br><strong>Domain:</strong> .rediff.com<br><strong>Path:</strong> &#x2F; (Any path after the domain name)<br><strong>Send For:</strong> Any type of connection<br><strong>Expires:</strong> Thursday, December 31, 2020, 11:59:59 PM</p>
<h4 id="Cookie可以使用在哪里？"><a href="#Cookie可以使用在哪里？" class="headerlink" title="Cookie可以使用在哪里？"></a>Cookie可以使用在哪里？</h4><p><strong>实现购物车：</strong> Cookie 用于维护在线订购系统。如果用户将某些产品添加到购物车中，并且由于某种原因用户这次不想购买这些产品并关闭浏览器窗口，该怎么办？Cookie记住用户想要购买的东西。下次同一用户访问购买页面时，他可以看到他在上次访问期间添加到购物车中的所有产品。</p>
<p><strong>个性化网站：</strong> 当用户访问某个页面时，系统会询问他们不想访问或显示哪些页面。用户选项存储在cookie中，直到用户在线，这些页面不会显示给他。</p>
<p><strong>用户跟踪：</strong> 跟踪特定时间的在线唯一身份访问者数量。</p>
<p><strong>营销：</strong> 一些公司使用Cookie在用户机器上显示广告。Cookie 控制这些广告。何时以及应显示哪个广告？用户的兴趣是什么？他们在网站上搜索哪些关键字？所有这些东西都可以使用cookie进行维护。</p>
<p><strong>用户会话：</strong> Cookie 可以使用用户 ID 和密码跟踪用户与特定域的会话。</p>
<h4 id="Cookie的缺点"><a href="#Cookie的缺点" class="headerlink" title="Cookie的缺点"></a>Cookie的缺点</h4><p><strong>用户禁用：</strong>使用Cookie是维护用户交互的好方法。但是如果用户在编写任何Cookie或完全禁用Cookie之前设置了浏览器选项以警告，则包含Cookie的网站将被完全禁用，并且无法执行任何操作，从而导致网站流量损失。这可以在浏览器设置中禁用&#x2F;启用。</p>
<p><strong>例如：</strong>对于谷歌浏览器，需要转到设置-&gt;高级-&gt;内容设置-&gt;Cookie。在那里，可以应用 Cookie 策略的一般规则，或为各个网站设置规则。</p>
<p><strong>Cookie 过多：</strong>如果在每个页面导航上写入了过多的 Cookie，并且用户在编写 Cookie 之前打开了警告选项，这甚至可能会使用户离开您的网站。</p>
<p><strong>安全问题：</strong>有时，用户的个人信息存储在Cookie中，如果有人入侵Cookie，那么黑客可以访问您的个人信息。即使是损坏的 Cookie 也可能被不同的域读取，并导致安全问题。</p>
<p><strong>敏感信息：</strong>某些网站可能会在Cookie中写入和存储敏感信息，出于隐私考虑，这不应该被允许。</p>
<h4 id="Cookie的测试用例"><a href="#Cookie的测试用例" class="headerlink" title="Cookie的测试用例"></a>Cookie的测试用例</h4><p><strong>#1）</strong>请确保在您的设计文档中，Cookie 中未存储任何个人或敏感数据。</p>
<p><strong>#2）</strong> 如果除了将敏感数据保存在 Cookie 中之外别无选择，请确保存储在 Cookie 中的数据以加密格式存储。</p>
<p><strong>#3）</strong>确保在被测的网站上没有过度使用 Cookie。如果浏览器更频繁地提示输入 Cookie，则过度使用 Cookie 会惹恼用户，这可能会导致网站流量损失并最终导致业务损失。</p>
<p><strong>#4）</strong>从您的浏览器设置中禁用 Cookie。如果您在网站上使用 Cookie，则禁用 Cookie 将无法使用您网站的主要功能。然后尝试访问受测网站。导航到该网站，查看是否向用户显示适当的消息，例如”为了使本网站顺利运行，请确保在您的浏览器上启用了Cookie”。任何页面都不应因禁用 Cookie 而崩溃。在执行此测试之前，请确保关闭所有浏览器并删除所有以前编写的cookie。</p>
<p><strong>#5）接受&#x2F;拒绝某些 Cookie：</strong>检查网站功能的最佳方法是不接受所有 Cookie。如果您在Web应用程序上编写10个Cookie，则随机接受一些Cookie，例如接受5个Cookie并拒绝5个Cookie。</p>
<p>要执行上述测试用例，您可以将浏览器选项设置为每当在磁盘上写入Cookie时都会提示。在此提示窗口中，您可以接受或拒绝 Cookie。尝试访问网站的主要功能，并查看页面是否崩溃或数据是否损坏。</p>
<p><strong>#6）删除 Cookie：</strong>允许网站编写 Cookie，然后关闭所有浏览器并手动删除受测网站的所有 Cookie。访问网页并检查网页的行为。</p>
<p><strong>#7）损坏 Cookie：</strong>损坏 Cookie 很容易。可以在记事本中手动编辑 Cookie，并将参数更改为一些模糊的值，例如更改 Cookie 内容、Cookie 名称或 Cookie 的到期日期，并查看网站功能。</p>
<p>在某些情况下，损坏的 Cookie 允许读取任何其他域的数据。对于网站 Cookie，不应发生这种情况。请注意，如果 Cookie 是由一个域编写的，如 rediff.com写的Cookie 另一个yahoo.com域无法访问它，除非 Cookie 已损坏并且有人试图破解 Cookie 数据。</p>
<p><strong>#8 ）检查从您的 Web 应用程序页面中删除 Cookie：</strong>有时，由域编写的 cookie 表示 rediff.com 可能由同一域删除，但由该域下的不同页面删除。如果您正在测试某操作跟Web 门户，则这是一般情况。操作跟踪或购买跟踪像素放置在操作网页上，当用户发生任何操作或购买时，写入磁盘上的Cookie将被删除，以避免从同一Cookie记录多个操作。检查到达您的操作或购买页面是否正确删除了Cookie，并且不再记录来自同一用户的无效操作或购买。</p>
<p><strong>#9）在多个浏览器上进行 Cookie 测试：</strong>这是检查您的 Web 应用程序页面是否按预期在不同的浏览器上正确编写 Cookie 以及网站是否使用这些 Cookie 正常工作的最重要情况。您可以在最常用的浏览器（如Chrome，Edge，Mozilla Firefox，Netscape，Opera等）上测试您的Web应用程序。</p>
<p><strong>#10）</strong>如果使用 Cookie 来维护任何用户的日志记录状态，请使用某些用户名和密码登录到您的 Web 应用程序。</p>
<p>在许多情况下，您可以直接在浏览器地址栏中看到登录的用户 ID 参数。将此参数更改为其他值，例如，如果以前的用户 ID 为 100，则将其设置为 101，然后按 Enter。应向用户显示正确的访问消息，并且用户不应能够看到其他用户的帐户详细信息。</p>
<p><strong>#11）</strong>通过在 Cookie 文件或浏览器控制台中检查 Cookie 类型和到期日期来验证 Cookie 是否持久（是否符合要求）</p>
<p><strong>#12）</strong>验证是否根据要求相应地设置了到期日期。在某些情况下，通过使用应用程序（例如刷新会话）来检查Cookie到期日期是否更新至关重要。这可以在浏览器控制台或 cookie 文件本身中进行检查。</p>
<p>请注意，手动解码cookie不是最佳方法，依赖浏览器数据更加容易。</p>
<p><strong>#13）</strong>如果某些 Cookie 是特定于用户的，请务必确保在其他用户登录应用程序时将其删除或直接忽略，除非另有说明。</p>
<p><strong>#14）针对多环境站点的特定测试：</strong>检查是否在所有环境中都可接受相同的 Cookie。问题可能是由 Cookie 路径中使用通配符（所谓的超级 cookie）引起的。如果这是允许它的要求，则由于使用了不同的加密密钥（例如，对于 .Net，除非另有指定，否则它通常是唯一的计算机密钥），因此可能会导致一些访问问题。</p>
<p>这些是测试网站 Cookie 时要考虑的一些主要测试用例。可以通过执行各种组合从这些测试用例编写多个测试用例。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/Echo/archives/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/Echo/archives/page/5/">5</a><a class="extend next" rel="next" href="/Echo/archives/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2020 – 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">丑牛</span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>

    </div>
  </footer>

  
  <script src="https://cdn.jsdelivr.net/npm/animejs@3.2.1/lib/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/Echo/js/comments.js"></script><script src="/Echo/js/utils.js"></script><script src="/Echo/js/motion.js"></script><script src="/Echo/js/next-boot.js"></script>

  
<script src="https://cdn.jsdelivr.net/npm/hexo-generator-searchdb@1.4.0/dist/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/Echo/js/third-party/search/local-search.js"></script>





  
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css" integrity="sha256-AJnUHL7dBv6PGaeyPQJcgQPDjt/Hn/PvYZde1iqfp8U=" crossorigin="anonymous">

<script class="next-config" data-name="gitalk" type="application/json">{"enable":true,"github_id":"hugfeature","repo":"myBlogTalk","client_id":"f4b1fae431a4943a75f3","client_secret":"2b6995c484ff0a0a920d65ac7fd5bb1bf13fb2f2","admin_user":null,"distraction_free_mode":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token","language":"zh-CN","js":{"url":"https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js","integrity":"sha256-Pmj85ojLaPOWwRtlMJwmezB/Qg8BzvJp5eTzvXaYAfA="},"path_md5":"62e7a0c6414fa96529635da1af7c9879"}</script>
<script src="/Echo/js/third-party/comments/gitalk.js"></script>

</body>
</html>
